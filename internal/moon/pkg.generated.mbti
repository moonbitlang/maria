// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/maria/internal/moon"

import(
  "moonbitlang/core/json"
)

// Values
async fn new(user? : String, name? : String, StringView, cwd? : StringView) -> Unit

async fn render_diagnostics(ArrayView[Diagnostic], limit~ : Int, overlay? : Map[String, String]) -> String noraise

// Errors

// Types and methods
type Artifacts
fn Artifacts::to_json(Self) -> Json // from trait `ToJson`
impl ToJson for Artifacts

type Coverage
async fn Coverage::analyze(Self, package_? : Package, file? : String) -> String
async fn Coverage::clean(Self, package_? : String) -> String
async fn Coverage::report(Self, package_? : String, output_file? : String, format? : CoverageFormat) -> String

pub(all) enum CoverageFormat {
  Bisect
  Caret
  Coveralls
  Cobertura
  Html
  Summary
}
fn CoverageFormat::output(Self, &Logger) -> Unit // from trait `Show`
fn CoverageFormat::to_string(Self) -> String // from trait `Show`
impl Show for CoverageFormat

pub struct Diagnostic {
  error_code : Int
  level : Level
  loc : Loc
  message : String
}
fn Diagnostic::from_json(Json, @json.JsonPath) -> Self raise @json.JsonDecodeError // from trait `@json.FromJson`
fn Diagnostic::output(Self, &Logger) -> Unit // from trait `Show`
fn Diagnostic::to_json(Self) -> Json // from trait `ToJson`
fn Diagnostic::to_string(Self) -> String // from trait `Show`
impl Show for Diagnostic
impl ToJson for Diagnostic
impl @json.FromJson for Diagnostic

type File
fn File::header(Self) -> SegmentView
fn File::lines(Self) -> Array[StringView]
fn File::output(Self, &Logger) -> Unit // from trait `Show`
fn File::path(Self) -> String
async fn File::replace_segment(Self, Int, String) -> Unit
fn File::segment(Self, Int) -> SegmentView
fn File::segments(Self) -> ArrayView[SegmentView]
fn File::to_json(Self) -> Json // from trait `ToJson`
fn File::to_string(Self) -> String // from trait `Show`
impl Show for File
impl ToJson for File

type Import
fn Import::from_json(Json, @json.JsonPath) -> Self raise @json.JsonDecodeError // from trait `@json.FromJson`
fn Import::output(Self, &Logger) -> Unit // from trait `Show`
fn Import::to_string(Self) -> String // from trait `Show`
impl Show for Import
impl @json.FromJson for Import

pub enum Level {
  Error
  Warning
}
fn Level::output(Self, &Logger) -> Unit // from trait `Show`
fn Level::to_json(Self) -> Json // from trait `ToJson`
fn Level::to_string(Self) -> String // from trait `Show`
impl Show for Level
impl ToJson for Level

pub struct Loc {
  end : Pos
  path : String
  start : Pos
}
fn Loc::output(Self, &Logger) -> Unit // from trait `Show`
fn Loc::to_json(Self) -> Json // from trait `ToJson`
fn Loc::to_string(Self) -> String // from trait `Show`
impl Show for Loc
impl ToJson for Loc

pub struct Module {
  path : String
  name : String
  coverage : Coverage
  // private fields
}
async fn Module::check(Self, patch_file? : StringView, target_dir? : StringView) -> Unit
async fn Module::check_patch_insert(Self, String, String) -> Array[Diagnostic]
async fn Module::check_patch_replace(Self, SegmentView, String) -> Array[Diagnostic]
async fn Module::diagnostics(Self) -> Iter[Diagnostic]
fn Module::files(Self) -> Iter[File]
async fn Module::find_package(Self, String) -> PackageView?
async fn Module::install(Self) -> Unit
async fn Module::load(String) -> Self
async fn Module::locate_package(Self, String) -> Package
fn Module::name(Self) -> String
fn Module::packages(Self) -> Iter[PackageView]
fn Module::source(Self) -> String
async fn Module::test_(Self, target_dir? : String, package_? : String, file? : String, index? : Int, enable_coverage? : Bool, debug? : Bool, release? : Bool, strip? : Bool, jobs? : Int, update? : Bool, limit? : Int, patch_file? : String) -> Array[TestFailure]
async fn Module::test_build_only(Self, target_dir? : String, package_? : String, file? : String, index? : Int, enable_coverage? : Bool, debug? : Bool, release? : Bool, strip? : Bool, jobs? : Int, update? : Bool, limit? : Int, patch_file? : String) -> Artifacts

type Package
fn Package::add_diagnostic(Self, Diagnostic) -> Unit
async fn Package::check(Self, patch_file? : StringView, target_dir? : StringView, cwd~ : StringView) -> Array[Diagnostic]
async fn Package::interface(Self) -> String?
fn Package::name(Self) -> String
fn Package::output(Self, &Logger) -> Unit // from trait `Show`
fn Package::path(Self) -> String
fn Package::to_json(Self) -> Json // from trait `ToJson`
fn Package::to_string(Self) -> String // from trait `Show`
impl Show for Package
impl ToJson for Package

pub struct PackageView {
  module_ : Module
  name : String
}
fn PackageView::files(Self) -> Iter[File]
async fn PackageView::info(Self) -> Unit
async fn PackageView::interface(Self) -> String
fn PackageView::is_main(Self) -> Bool
fn PackageView::name(Self) -> String
fn PackageView::package_(Self) -> Package
fn PackageView::to_json(Self) -> Json // from trait `ToJson`
impl ToJson for PackageView

pub struct Pos {
  col : Int
  line : Int
}
fn Pos::output(Self, &Logger) -> Unit // from trait `Show`
fn Pos::to_json(Self) -> Json // from trait `ToJson`
fn Pos::to_string(Self) -> String // from trait `Show`
impl Show for Pos
impl ToJson for Pos

type SegmentView
fn SegmentView::content(Self) -> String
fn SegmentView::diagnostics(Self) -> Array[Diagnostic]
async fn SegmentView::replace(Self, String) -> Unit
fn SegmentView::to_json(Self) -> Json // from trait `ToJson`
impl ToJson for SegmentView

type TestFailure
fn TestFailure::to_json(Self) -> Json // from trait `ToJson`
impl ToJson for TestFailure

// Type aliases

// Traits

