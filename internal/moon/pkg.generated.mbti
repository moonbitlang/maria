// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/maria/internal/moon"

import(
  "moonbitlang/core/json"
  "moonbitlang/maria/internal/diagnostics"
)

// Values
pub async fn check_syntax_of_file(String, cwd? : StringView) -> @diagnostics.Diagnostics

pub async fn check_syntax_of_string(path? : String, String) -> @diagnostics.Diagnostics

pub async fn format_string(String) -> String

pub fn home() -> String raise

pub async fn new(user? : String, name? : String, StringView, cwd? : StringView) -> Unit

// Errors

// Types and methods
type Artifacts
pub impl ToJson for Artifacts

type Coverage
pub async fn Coverage::analyze(Self, package_? : Package, file? : String) -> String
pub async fn Coverage::clean(Self, package_? : String) -> String
pub async fn Coverage::report(Self, package_? : String, output_file? : String, format? : CoverageFormat) -> String

pub(all) enum CoverageFormat {
  Bisect
  Caret
  Coveralls
  Cobertura
  Html
  Summary
}
pub impl Show for CoverageFormat

type File
pub fn File::header(Self) -> SegmentView
pub fn File::lines(Self) -> Array[StringView]
pub fn File::path(Self) -> String
pub fn File::segment(Self, Int) -> SegmentView
pub fn File::segments(Self) -> ArrayView[SegmentView]
pub async fn File::write(Self, String) -> Unit
pub impl Show for File
pub impl ToJson for File

type Import
pub impl Show for Import
pub impl @json.FromJson for Import

pub struct Module {
  path : String
  name : String
  source : String
  version : String
  description : String
  coverage : Coverage
  // private fields
}
pub async fn Module::check(Self, patch_file? : StringView, target_dir? : StringView) -> Unit
pub async fn Module::check_patch_insert(Self, String, String) -> @diagnostics.Diagnostics
pub async fn Module::check_patch_replace(Self, SegmentView, String) -> @diagnostics.Diagnostics
pub async fn Module::diagnostics(Self) -> @diagnostics.Diagnostics
pub fn Module::files(Self) -> Iter[File]
pub async fn Module::find_package(Self, String) -> PackageView?
pub async fn Module::install(Self) -> Unit
pub async fn Module::load(String) -> Self
pub async fn Module::locate_package(Self, String) -> Package
pub fn Module::packages(Self) -> Iter[PackageView]
pub async fn Module::publish(Self, dry_run? : Bool) -> Unit
pub async fn Module::run(Self, String, Array[String]) -> (Int, String)
pub async fn Module::test_(Self, target_dir? : String, package_? : String, file? : String, index? : Int, enable_coverage? : Bool, debug? : Bool, release? : Bool, strip? : Bool, jobs? : Int, update? : Bool, limit? : Int, patch_file? : String) -> Unit
pub async fn Module::test_build_only(Self, target_dir? : String, package_? : String, file? : String, index? : Int, enable_coverage? : Bool, debug? : Bool, release? : Bool, strip? : Bool, jobs? : Int, update? : Bool, limit? : Int, patch_file? : String) -> Artifacts

type Package
pub fn Package::add_diagnostic(Self, @diagnostics.Diagnostic) -> Unit
pub async fn Package::check(Self, patch_file? : StringView, target_dir? : StringView, cwd~ : StringView) -> @diagnostics.Diagnostics
pub async fn Package::interface(Self) -> String?
pub fn Package::name(Self) -> String
pub fn Package::path(Self) -> String
pub impl Show for Package
pub impl ToJson for Package

pub struct PackageView {
  module_ : Module
  name : String
}
pub fn PackageView::files(Self) -> Iter[File]
pub async fn PackageView::info(Self) -> Unit
pub async fn PackageView::interface(Self) -> String
pub fn PackageView::is_main(Self) -> Bool
pub fn PackageView::name(Self) -> String
pub fn PackageView::package_(Self) -> Package
pub impl ToJson for PackageView

type SegmentView
pub fn SegmentView::content(Self) -> String
pub fn SegmentView::diagnostics(Self) -> @diagnostics.Diagnostics
pub fn SegmentView::replace(Self, String) -> String
pub impl ToJson for SegmentView

// Type aliases

// Traits

