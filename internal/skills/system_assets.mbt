///|
/// Auto-generated by `scripts/embed-skills.py`. Do not edit by hand.
let system_assets : Array[@assets.Asset] = [
  @assets.Asset::{
    path: "moonbit-agent-guide/LICENSE",
    content: (
      #|
      #|                                 Apache License
      #|                           Version 2.0, January 2004
      #|                        http://www.apache.org/licenses/
      #|
      #|   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
      #|
      #|   1. Definitions.
      #|
      #|      "License" shall mean the terms and conditions for use, reproduction,
      #|      and distribution as defined by Sections 1 through 9 of this document.
      #|
      #|      "Licensor" shall mean the copyright owner or entity authorized by
      #|      the copyright owner that is granting the License.
      #|
      #|      "Legal Entity" shall mean the union of the acting entity and all
      #|      other entities that control, are controlled by, or are under common
      #|      control with that entity. For the purposes of this definition,
      #|      "control" means (i) the power, direct or indirect, to cause the
      #|      direction or management of such entity, whether by contract or
      #|      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      #|      outstanding shares, or (iii) beneficial ownership of such entity.
      #|
      #|      "You" (or "Your") shall mean an individual or Legal Entity
      #|      exercising permissions granted by this License.
      #|
      #|      "Source" form shall mean the preferred form for making modifications,
      #|      including but not limited to software source code, documentation
      #|      source, and configuration files.
      #|
      #|      "Object" form shall mean any form resulting from mechanical
      #|      transformation or translation of a Source form, including but
      #|      not limited to compiled object code, generated documentation,
      #|      and conversions to other media types.
      #|
      #|      "Work" shall mean the work of authorship, whether in Source or
      #|      Object form, made available under the License, as indicated by a
      #|      copyright notice that is included in or attached to the work
      #|      (an example is provided in the Appendix below).
      #|
      #|      "Derivative Works" shall mean any work, whether in Source or Object
      #|      form, that is based on (or derived from) the Work and for which the
      #|      editorial revisions, annotations, elaborations, or other modifications
      #|      represent, as a whole, an original work of authorship. For the purposes
      #|      of this License, Derivative Works shall not include works that remain
      #|      separable from, or merely link (or bind by name) to the interfaces of,
      #|      the Work and Derivative Works thereof.
      #|
      #|      "Contribution" shall mean any work of authorship, including
      #|      the original version of the Work and any modifications or additions
      #|      to that Work or Derivative Works thereof, that is intentionally
      #|      submitted to Licensor for inclusion in the Work by the copyright owner
      #|      or by an individual or Legal Entity authorized to submit on behalf of
      #|      the copyright owner. For the purposes of this definition, "submitted"
      #|      means any form of electronic, verbal, or written communication sent
      #|      to the Licensor or its representatives, including but not limited to
      #|      communication on electronic mailing lists, source code control systems,
      #|      and issue tracking systems that are managed by, or on behalf of, the
      #|      Licensor for the purpose of discussing and improving the Work, but
      #|      excluding communication that is conspicuously marked or otherwise
      #|      designated in writing by the copyright owner as "Not a Contribution."
      #|
      #|      "Contributor" shall mean Licensor and any individual or Legal Entity
      #|      on behalf of whom a Contribution has been received by Licensor and
      #|      subsequently incorporated within the Work.
      #|
      #|   2. Grant of Copyright License. Subject to the terms and conditions of
      #|      this License, each Contributor hereby grants to You a perpetual,
      #|      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      #|      copyright license to reproduce, prepare Derivative Works of,
      #|      publicly display, publicly perform, sublicense, and distribute the
      #|      Work and such Derivative Works in Source or Object form.
      #|
      #|   3. Grant of Patent License. Subject to the terms and conditions of
      #|      this License, each Contributor hereby grants to You a perpetual,
      #|      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      #|      (except as stated in this section) patent license to make, have made,
      #|      use, offer to sell, sell, import, and otherwise transfer the Work,
      #|      where such license applies only to those patent claims licensable
      #|      by such Contributor that are necessarily infringed by their
      #|      Contribution(s) alone or by combination of their Contribution(s)
      #|      with the Work to which such Contribution(s) was submitted. If You
      #|      institute patent litigation against any entity (including a
      #|      cross-claim or counterclaim in a lawsuit) alleging that the Work
      #|      or a Contribution incorporated within the Work constitutes direct
      #|      or contributory patent infringement, then any patent licenses
      #|      granted to You under this License for that Work shall terminate
      #|      as of the date such litigation is filed.
      #|
      #|   4. Redistribution. You may reproduce and distribute copies of the
      #|      Work or Derivative Works thereof in any medium, with or without
      #|      modifications, and in Source or Object form, provided that You
      #|      meet the following conditions:
      #|
      #|      (a) You must give any other recipients of the Work or
      #|          Derivative Works a copy of this License; and
      #|
      #|      (b) You must cause any modified files to carry prominent notices
      #|          stating that You changed the files; and
      #|
      #|      (c) You must retain, in the Source form of any Derivative Works
      #|          that You distribute, all copyright, patent, trademark, and
      #|          attribution notices from the Source form of the Work,
      #|          excluding those notices that do not pertain to any part of
      #|          the Derivative Works; and
      #|
      #|      (d) If the Work includes a "NOTICE" text file as part of its
      #|          distribution, then any Derivative Works that You distribute must
      #|          include a readable copy of the attribution notices contained
      #|          within such NOTICE file, excluding those notices that do not
      #|          pertain to any part of the Derivative Works, in at least one
      #|          of the following places: within a NOTICE text file distributed
      #|          as part of the Derivative Works; within the Source form or
      #|          documentation, if provided along with the Derivative Works; or,
      #|          within a display generated by the Derivative Works, if and
      #|          wherever such third-party notices normally appear. The contents
      #|          of the NOTICE file are for informational purposes only and
      #|          do not modify the License. You may add Your own attribution
      #|          notices within Derivative Works that You distribute, alongside
      #|          or as an addendum to the NOTICE text from the Work, provided
      #|          that such additional attribution notices cannot be construed
      #|          as modifying the License.
      #|
      #|      You may add Your own copyright statement to Your modifications and
      #|      may provide additional or different license terms and conditions
      #|      for use, reproduction, or distribution of Your modifications, or
      #|      for any such Derivative Works as a whole, provided Your use,
      #|      reproduction, and distribution of the Work otherwise complies with
      #|      the conditions stated in this License.
      #|
      #|   5. Submission of Contributions. Unless You explicitly state otherwise,
      #|      any Contribution intentionally submitted for inclusion in the Work
      #|      by You to the Licensor shall be under the terms and conditions of
      #|      this License, without any additional terms or conditions.
      #|      Notwithstanding the above, nothing herein shall supersede or modify
      #|      the terms of any separate license agreement you may have executed
      #|      with Licensor regarding such Contributions.
      #|
      #|   6. Trademarks. This License does not grant permission to use the trade
      #|      names, trademarks, service marks, or product names of the Licensor,
      #|      except as required for reasonable and customary use in describing the
      #|      origin of the Work and reproducing the content of the NOTICE file.
      #|
      #|   7. Disclaimer of Warranty. Unless required by applicable law or
      #|      agreed to in writing, Licensor provides the Work (and each
      #|      Contributor provides its Contributions) on an "AS IS" BASIS,
      #|      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      #|      implied, including, without limitation, any warranties or conditions
      #|      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      #|      PARTICULAR PURPOSE. You are solely responsible for determining the
      #|      appropriateness of using or redistributing the Work and assume any
      #|      risks associated with Your exercise of permissions under this License.
      #|
      #|   8. Limitation of Liability. In no event and under no legal theory,
      #|      whether in tort (including negligence), contract, or otherwise,
      #|      unless required by applicable law (such as deliberate and grossly
      #|      negligent acts) or agreed to in writing, shall any Contributor be
      #|      liable to You for damages, including any direct, indirect, special,
      #|      incidental, or consequential damages of any character arising as a
      #|      result of this License or out of the use or inability to use the
      #|      Work (including but not limited to damages for loss of goodwill,
      #|      work stoppage, computer failure or malfunction, or any and all
      #|      other commercial damages or losses), even if such Contributor
      #|      has been advised of the possibility of such damages.
      #|
      #|   9. Accepting Warranty or Additional Liability. While redistributing
      #|      the Work or Derivative Works thereof, You may choose to offer,
      #|      and charge a fee for, acceptance of support, warranty, indemnity,
      #|      or other liability obligations and/or rights consistent with this
      #|      License. However, in accepting such obligations, You may act only
      #|      on Your own behalf and on Your sole responsibility, not on behalf
      #|      of any other Contributor, and only if You agree to indemnify,
      #|      defend, and hold each Contributor harmless for any liability
      #|      incurred by, or claims asserted against, such Contributor by reason
      #|      of your accepting any such warranty or additional liability.
      #|
      #|   END OF TERMS AND CONDITIONS
      #|
      #|   APPENDIX: How to apply the Apache License to your work.
      #|
      #|      To apply the Apache License to your work, attach the following
      #|      boilerplate notice, with the fields enclosed by brackets "[]"
      #|      replaced with your own identifying information. (Don't include
      #|      the brackets!)  The text should be enclosed in the appropriate
      #|      comment syntax for the file format. We also recommend that a
      #|      file or class name and description of purpose be included on the
      #|      same "printed page" as the copyright notice for easier
      #|      identification within third-party archives.
      #|
      #|   Copyright [yyyy] [name of copyright owner]
      #|
      #|   Licensed under the Apache License, Version 2.0 (the "License");
      #|   you may not use this file except in compliance with the License.
      #|   You may obtain a copy of the License at
      #|
      #|       http://www.apache.org/licenses/LICENSE-2.0
      #|
      #|   Unless required by applicable law or agreed to in writing, software
      #|   distributed under the License is distributed on an "AS IS" BASIS,
      #|   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      #|   See the License for the specific language governing permissions and
      #|   limitations under the License.
    ),
  },
  @assets.Asset::{
    path: "moonbit-agent-guide/README.md",
    content: (
      #|# MoonBit System Prompt
      #|
      #|[`Agents.mbt.md`](./Agents.mbt.md) contains the MoonBit System Prompt, a
      #|descriptive system prompt designed to enhance the performance of code agents
      #|over MoonBit projects.
      #|
      #|## How to use
      #|
      #|The simplest way is to reference the file and ask the AI to read it in the prompt.
      #|
      #|Here we provide some extra instructions on how to use the MoonBit System Prompt in
      #|different code agents.
      #|
      #|### AGENTS.md
      #|
      #|Many AI code agents now have adopted the [`AGENTS.md`](https://agents.md)
      #|convention for providing guidance for agents. For such agents, you may:
      #|
      #|- Copy `Agents.mbt.md` into your project directory as `AGENTS.md`
      #|- Append the content of `Agents.mbt.md` to your existing `AGENTS.md` file.
      #|
      #|### Claude Code
      #|
      #|[Claude Code](https://www.anthropic.com/claude-code) supports `CLAUDE.md` file.
      #|Since `CLAUDE.md` supports `@path/to/import` syntax, we suggest copying
      #|`Agents.mbt.md` into your project directory and mention it in `CLAUDE.md`. For
      #|example, suppose you copied `Agents.mbt.md` to your project directory as
      #|`moonbit.mbt.md`, then you can add the following line to your `CLAUDE.md` file:
      #|
      #|```markdown
      #|# MoonBit Language Reference
      #|- @moonbit.mbt.md
      #|```
      #|
      #|See [Memory Management](https://docs.claude.com/en/docs/claude-code/memory)
      #|on detailed configuration.
      #|
      #|### Codex CLI
      #|
      #|Codex CLI supports [`AGENTS.md`](https://agents.md).
      #|Quoted from [openai/codex/docs/getting-started.md](https://github.com/openai/codex/blob/main/docs/getting-started.md#memory-with-agentsmd):
      #|
      #|> You can give Codex extra instructions and guidance using `AGENTS.md` files.
      #|> Codex looks for `AGENTS.md` files in the following places, and merges them
      #|> top-down:
      #|>
      #|> 1. `~/.codex/AGENTS.md` - personal global guidance
      #|> 2. `AGENTS.md` at repo root - shared project notes
      #|> 3. `AGENTS.md` in the current working directory - sub-folder/feature specifics
      #|>
      #|> For more information on how to use AGENTS.md, see the [official AGENTS.md
      #|> documentation](https://agents.md/).
      #|
      #|### Cursor & Cursor CLI
      #|
      #|[Cursor](https://cursor.com/) supports `AGENTS.md` files. See the
      #|[`AGENTS.md`](#agentsmd) section above for details.
      #|
      #|Also, one can use [rules](https://docs.cursor.com/en/context/rules) to include the
      #|content of `Agents.mbt.md` file. For project rule, you can copy `Agents.mbt.md`
      #|to `.cursor/rules/moonbit.mdc`, and configure ways to include the
      #|context in the front-matter of `.cursor/rules/moonbit.mdc`. For example:
      #|
      #|```markdown
      #|---
      #|description: "MoonBit System Prompt"
      #|globs:
      #|alwaysApply: true
      #|---
      #|...
      #|```
      #|
      #|See <https://docs.cursor.com/en/context/rules> for more details.
      #|
      #|[Cursor CLI supports the same rules system as the IDE](https://docs.cursor.com/en/cli/using#rules)
      #|
      #|### Gemini CLI
      #|
      #|[Gemini-CLI](https://github.com/google-gemini/gemini-cli) reads from `GEMINI.md`
      #|files for user-level/repository-specific instructions/contexts. Since
      #|it supports `@` memory import, we suggest copying `Agents.mbt.md` into your
      #|project directory and mention it in `GEMINI.md`. For example, suppose you
      #|copied `Agents.mbt.md` to your project directory as `moonbit.mbt.md`, then you
      #|can add the following line to your `GEMINI.md` file:
      #|
      #|```markdown
      #|# MoonBit Language Reference
      #|- @moonbit.mbt.md
      #|```
      #|
      #|See [Memory Import Processor](https://github.com/google-gemini/gemini-cli/blob/1634d5fcca29e7c64d37f99e17e42d303e12062d/docs/core/memport.md) for more information.
      #|
      #|Also, Gemini-CLI can be configured to use `AGENTS.md` files, as per
      #|<https://agents.md>:
      #|
      #|> **How do I configure Gemini CLI?**
      #|>
      #|> Configure Gemini CLI to use AGENTS.md in .gemini/settings.json:
      #|>
      #|> ```json
      #|> { "contextFileName": "AGENTS.md" }
      #|> ```
      #|
      #|### GitHub Copilot for VS Code
      #|
      #|VS Code Copilot [experimentally supports `AGENTS.md`](https://code.visualstudio.com/docs/copilot/customization/custom-instructions#_use-an-agentsmd-file-experimental).
      #|
      #|When working with multi-language projects, you may want to limit the scope
      #|of the system prompt to specifically MoonBit-related files. You can do this by
      #|creating a `.github/instructions/moonbit.instructions.md` file with the
      #|following content:
      #|
      #|```markdown
      #|---
      #|applyTo: "**/*.mbt,**/*.mbti,**/moon.mod.json,**/moon.pkg.json,**/*.mbt.md"
      #|---
      #|[Content of Agents.mbt.md]
      #|```
    ),
  },
  @assets.Asset::{
    path: "moonbit-agent-guide/SKILL.mbt.md",
    content: (
      #|---
      #|name: moonbit-agent-guide
      #|description: Guide for writing, refactoring, and testing MoonBit projects. Use when working in MoonBit modules or packages, organizing MoonBit files, using moon tooling (build/check/test/doc/ide), or following MoonBit-specific layout, documentation, and testing conventions.
      #|---
      #|
      #|# MoonBit Project Layouts
      #|
      #|MoonBit use the `.mbt` extension and interface files `.mbti`. At
      #|the top-level of a MoonBit project there is a `moon.mod.json` file specifying
      #|the metadata of the project. The project may contain multiple packages, each
      #|with its own `moon.pkg.json` file.
      #|
      #|## Example layout
      #|
      #|```
      #|my_module
      #|├── moon.mod.json             # Module metadata, source field(optional) specifies the source directory of the module
      #|├── moon.pkg.json             # Package metadata (each directory is a package like Golang)
      #|├── README.mbt.md             # Markdown with tested code blocks (`test "..." { ... }`)
      #|├── README.md -> README.mbt.md
      #|├── cmd                       # Command line directory
      #|│   └── main
      #|│       ├── main.mbt
      #|│       └── moon.pkg.json     # executable package with {"is_main": true}
      #|├── liba/                     # Library packages
      #|│   └── moon.pkg.json         # Referenced by other packages as `@username/my_module/liba`
      #|│   └── libb/                 # Library packages
      #|│       └── moon.pkg.json     # Referenced by other packages as `@username/my_module/liba/libb`
      #|├── user_pkg.mbt              # Root packages, referenced by other packages as `@username/my_module`
      #|├── user_pkg_wbtest.mbt       # White-box tests (only needed for testing internal private members, similar to Golang's package mypackage)
      #|└── user_pkg_test.mbt         # Black-box tests
      #|└── ...                       # More package files, symbols visible to current package (like Golang)
      #|```
      #|
      #|- **Module**:  `moon.mod.json` file in the project directory.
      #|  A MoonBit *module* is like a Go module,it is a collection of packages in subdirectories, usually corresponding to a repository or project.
      #|  Module boundaries matter for dependency management and import paths.
      #|
      #|- **Package**: a `moon.pkg.json` file per directory. 
      #|  All subcommands of `moon` will
      #|  still be executed in the directory of the module (where `moon.mod.json` is
      #|  located), not the current package.
      #|  A MoonBit *package* is the actual compilation unit (like a Go package).
      #|  All source files in the same package are concatenated into one unit.
      #|  The `package` name in the source defines the package, not the file name.
      #|  Imports refer to module + package paths, NEVER to file names.
      #|
      #|- **Files**:
      #|  A `.mbt` file is just a chunk of source inside a package.
      #|  File names do NOT create modules or namespaces.
      #|  You may freely split/merge/move declarations between files in the same package.
      #|  Any declaration in a package can reference any other declaration in that package, regardless of file.
      #|
      #|
      #|## Coding/layout rules you MUST follow:
      #|
      #|1. Prefer many small, cohesive files over one large file.
      #|   - Group related types and functions into focused files (e.g. http_client.mbt, router.mbt).
      #|   - If a file is getting large or unfocused, create a new file and move related declarations into it.
      #|
      #|2. You MAY freely move declarations between files inside the same package.
      #|   - Each block is separated by `///|`, moving a function/struct/trait between files does not change semantics, as long as its name and pub-ness stay the same, the order of each block is irrelevant too.
      #|   - It is safe to refactor by splitting or merging files inside a package.
      #|
      #|3. File names are purely organizational.
      #|   - Do NOT assume file names define modules, and do NOT use file names in type paths.
      #|   - Choose file names to describe a feature or responsibility, not to mirror type names rigidly.
      #|
      #|4. When adding new code:
      #|   - Prefer adding it to an existing file that matches the feature.
      #|   - If no good file exists, create a new file under the same package with a descriptive name.
      #|   - Avoid creating giant “misc” or “util” files.
      #|
      #|5. Tests:
      #|   - Place tests in dedicated test files (e.g. *_test.mbt) within the appropriate package.
      #|     For a package, besides `*_test.mbt`files,`*.mbt.md`are also blackbox test files, the code block `mbt check` are treated as test cases, they serve both purposes: documentation and tests.      
      #|     You may have `README.mbt.md` files with `mbt check` code examples, you can also symlink `README.mbt.md` to `README.md`
      #|     to make it integrate better with GitHub.
      #|   - It is fine—and encouraged—to have multiple small test files.
      #|
      #|6. Interface files(`pkg.generated.mbti`) 
      #|   `pkg.generated.mbti` is compiler-generated summaries of each package's public API surface. They provide a formal, concise overview of all exported types, functions, and traits without implementation details.
      #|   They are generated using `moon info`, useful for code review, when you have a commit that does not change public APIs, `pkg.generated.mbti` files will remain unchanged, so it is recommended to put `pk.generated.mbti` in version control when you are done.
      #|   
      #|   You can also use `moon doc @moonbitlang/core/strconv` to explore the public API of a package interactively and `moon ide peek-def 'Array::join'` to read
      #|   the definition.
      #|
      #|# Common Pitfalls to Avoid
      #|
      #|- **Don't use uppercase for variables/functions** - compilation error
      #|- **Don't forget `mut` for mutable record fields** - immutable by default
      #|- **Don't ignore error handling** - errors must be explicitly handled
      #|- **Don't use `return` unnecessarily** - last expression is the return value
      #|- **Don't create methods without Type:: prefix** - methods need explicit type prefix
      #|- **Don't forget to handle array bounds** - use `get()` for safe access
      #|- **Don't forget @package prefix when calling functions from other packages**
      #|- **Don't use ++ or -- (not supported)** - use `i = i + 1` or `i += 1`
      #|- **Don't add explicit `try` for error-raising functions** - errors propagate automatically (unlike Swift)
      #|- **Legacy syntax**: Older code may use `function_name!(...)` or `function_name(...)?` - these are deprecated; use normal calls and `try?` for Result conversion
      #|
      #|
      #|# `moon` Essentials
      #|
      #|## Essential Commands
      #|
      #|- `moon new my_project` - Create new project
      #|- `moon run cmd/main` - Run main package
      #|- `moon build` - Build project
      #|- `moon check` - Type check without building, use it REGULARLY, it is fast
      #|- `moon info` - Type check and generate `mbti` files
      #|  run it to see if any public interfaces changed.
      #|- `moon check --target all` - Type check for all backends
      #|- `moon add package` - Add dependency
      #|- `moon remove package` - Remove dependency
      #|- `moon fmt` - Format code
      #|
      #|### Test Commands
      #|
      #|- `moon test` - Run all tests
      #|- `moon test --update` - Update snapshots
      #|- `moon test -v` - Verbose output with test names
      #|- `moon test [dirname|filename]` - Test specific directory or file
      #|- `moon coverage analyze` - Analyze coverage
      #|
      #|
      #|## `README.mbt.md` Generation Guide
      #|
      #|- Output `README.mbt.md` in the package directory. 
      #|  `*.mbt.md` file and docstring contents treats `mbt check` specially.
      #|  `mbt check` block will be included directly as code and also run by `moon check` and `moon test`.  If you don't want the code snippets to be checked, explicit `mbt nocheck` is preferred.
      #|  If you are only referencing types from the package, you should use `mbt nocheck` which will only be syntax highlighted.
      #|  Symlink `README.mbt.md` to `README.md` to adapt to systems that expect `README.md`. 
      #|    
      #|## Testing Guide
      #|
      #|Use snapshot tests as it is easy to update when behavior changes.
      #|
      #|- **Snapshot Tests**: `inspect(value, content="...")`. If unknown, write `inspect(value)` and run `moon test --update` (or `moon test -u`).
      #|  - Use regular `inspect()` for simple values (uses `Show` trait)
      #|  - Use `json_inspect()` for complex nested structures (uses `ToJson` trait, produces more readable output)
      #|  - It is encouraged to `inspect` or `json_inspect` the whole return value of a function if
      #|    the whole return value is not huge, this makes test simple. You need `impl (Show|ToJson) for YourType` or `derive (Show, ToJson)`.
      #|- **Update workflow**: After changing code that affects output, run `moon test --update` to regenerate snapshots, then review the diffs in your test files (the `content=` parameter will be updated automatically).
      #|
      #|- Black-box by default: Call only public APIs via `@package.fn`. Use white-box tests only when private members matter.
      #|- Grouping: Combine related checks in one `test "..." { ... }` block for speed and clarity.
      #|- Panics: Name test with prefix `test "panic ..." {...}`; if the call returns a value, wrap it with `ignore(...)` to silence warnings.
      #|- Errors: Use `try? f()` to get `Result[...]` and `inspect` it when a function may raise.
      #|- Verify: Run `moon test` (or `-u` to update snapshots) and `moon fmt` afterwards.
      #|
      #|### Docstring tests 
      #|
      #|Public APIs are encouraged to have docstring tests.
      #|````mbt check
      #|///|
      #|/// Get the largest element of a non-empty `Array`.
      #|///
      #|/// # Example
      #|/// ```mbt check
      #|/// test {
      #|///   inspect(sum_array([1, 2, 3, 4, 5, 6]), content="21")
      #|/// }
      #|/// ```
      #|///
      #|/// # Panics
      #|/// Panics if the `xs` is empty.
      #|pub fn sum_array(xs : Array[Int]) -> Int {
      #|  xs.fold(init=0, (a, b) => a + b)
      #|}
      #|````
      #|
      #|The MoonBit code in docstring will be type checked and tested automatically.
      #|(using `moon test --update`). In docstrings, `mbt check` should only contain `test` or `async test`.
      #|
      #|## Spec-driven Development
      #|
      #|- The spec can be written in a readonly `spec.mbt` file (name is conventional, not mandatory) with stub code marked as declarations:
      #|
      #|```mbt check
      #|///|
      #|#declaration_only
      #|pub type Yaml
      #|
      #|///|
      #|#declaration_only
      #|pub fn Yaml::to_string(y : Yaml) -> String raise {
      #|  ...
      #|}
      #|
      #|///|
      #|#declaration_only
      #|pub fn parse_yaml(s : String) -> Yaml raise {
      #|  ...
      #|}
      #|```
      #|
      #|- Add `spec_easy_test.mbt`, `spec_difficult_test.mbt` etc to test the spec functions; everything will be type-checked(`moon check`).
      #|- The AI or students can implement the `declaration_only` functions in different files thanks to our package organization.
      #|- Run `moon test` to check everything is correct.
      #|
      #|- `#declaration_only` is supported for functions, methods, and types.
      #|- The `pub type Yaml` line is an intentionally opaque placeholder; the implementer chooses its representation.
      #|- Note the spec file can also contain normal code, not just declarations.
      #|
      #|## `moon doc` for API Discovery
      #|
      #|**CRITICAL**: `moon doc '<query>'` is your PRIMARY tool for discovering available APIs, functions, types, and methods in MoonBit. Always prefer `moon doc` over other approaches when exploring what APIs are available, it is **more powerful and accurate** than `grep_search` or any regex-based searching tools. 
      #|
      #|
      #|`moon doc` uses a specialized query syntax designed for symbol lookup:
      #|- **Empty query**: `moon doc ''`
      #|
      #|  - In a module: shows all available packages in current module, including dependencies and moonbitlang/core
      #|  - In a package: shows all symbols in current package
      #|  - Outside package: shows all available packages
      #|
      #|- **Function/value lookup**: `moon doc "[@pkg.]value_or_function_name"`
      #|  
      #|- **Type lookup**: `moon doc "[@pkg.]Type_name"` (builtin type does not need package prefix)
      #|
      #|- **Method/field lookup**: `moon doc "[@pkg.]Type_name::method_or_field_name"`
      #|
      #|- **Package exploration**: `moon doc "@pkg"`
      #|  - Show package `pkg` and list all its exported symbols
      #|  - Example: `moon doc "@json"` - explore entire `@json` package
      #|  - Example: `moon doc "@encoding/utf8"` - explore nested package
      #|
      #|- **Globbing**: Use `*` wildcard for partial matches, e.g. `moon doc "String::*rev*"` to find all String methods with "rev" in their name
      #|
      #|### `moon doc` Examples
      #|
      #|````bash
      #|# search for String methods in standard library:
      #|$ moon doc "String"
      #|
      #|type String
      #|
      #|  pub fn String::add(String, String) -> String
      #|  # ... more methods omitted ...
      #|
      #|$ moon doc "@buffer" # list all symbols in  package buffer:
      #|moonbitlang/core/buffer
      #|
      #|fn from_array(ArrayView[Byte]) -> Buffer
      #|# ... omitted ...
      #|
      #|$ moon doc "@buffer.new" # list the specific function in a package:
      #|package "moonbitlang/core/buffer"
      #|
      #|pub fn new(size_hint? : Int) -> Buffer
      #|  Creates ... omitted ...
      #|
      #|
      #|$ moon doc "String::*rev*"  # globbing
      #|package "moonbitlang/core/string"
      #|
      #|pub fn String::rev(String) -> String
      #|  Returns ... omitted ...
      #|  # ... more
      #|
      #|pub fn String::rev_find(String, StringView) -> Int?
      #|  Returns ... omitted ...
      #|````
      #|**Best practice**: When implementing a feature, start with `moon doc` queries to discover available APIs before writing code. This is faster and more accurate than searching through files.
      #|
      #|## `moon ide [peek-def|outline|find-references]` for code navigation and refactoring
      #|
      #|For project-local symbols and navigation, use `moon ide outline .` to scan a package, `moon ide find-references <symbol>` to locate usages, and `moon ide peek-def` for inline definition context and locate toplevel symbols. 
      #|
      #|These tools save tokens and more precise than grepping(grep display results in both definition and call site including comments too).
      #|
      #|### `moon ide peek-def sym [-loc filename:line:col]` example
      #|
      #|When the user ask: Can you check if `Parser::read_u32_leb128` is implemented correctly?
      #|
      #|In this case, You can run `moon ide peek-def Parser::read_u32_leb128` to get the definition context: (this is better than `grep` since it searches the whole project by semantics)
      #|
      #|``` file src/parse.mbt
      #|L45:|///|
      #|L46:|fn Parser::read_u32_leb128(self : Parser) -> UInt raise ParseError {
      #|L47:|  ...
      #|...:| }
      #|```
      #|Now you want to see the definition of `Parser` struct, you can run:
      #|
      #|```bash
      #|$ moon ide peek-def Parser -loc src/parse.mbt:46:4
      #|Definition found at file src/parse.mbt
      #|  | ///|
      #|2 | priv struct Parser {
      #|  |             ^^^^^^
      #|  |   bytes : Bytes
      #|  |   mut pos : Int
      #|  | }  
      #|  | 
      #|```
      #|For the `-loc` argument, the line number must be precise; the column can be approximate since 
      #|the positonal argument `Parser` helps locate the position.
      #|
      #|If the sym is toplevel symbol, the location can be omitted:
      #|````bash
      #|$ moon ide peek-def String::rev
      #|Found 1 symbols matching 'String::rev':
      #|
      #|`pub fn String::rev` in package moonbitlang/core/builtin at /Users/usrname/.moon/lib/core/builtin/string_methods.mbt:1039-1044
      #|1039 | ///|
      #|     | /// Returns a new string with the characters in reverse order. It respects
      #|     | /// Unicode characters and surrogate pairs but not grapheme clusters.
      #|     | pub fn String::rev(self : String) -> String {
      #|     |   self[:].rev()
      #|     | }         
      #|````
      #|
      #|### `moon ide outline [dir|file]` and `moon ide find-references <sym>` for Package Symbols
      #|
      #|Use this to scan a package or file for top-level symbols and locate usages without grepping
      #|
      #|- `moon ide outline dir` outlines the current package directory (per-file headers)
      #|- `moon ide outline parser.mbt` outlines a single file
      #|- Useful when you need a quick inventory of a package, or to find the right file before `goto-definition`
      #|- `moon ide find-references TranslationUnit` finds all references to a symbol in the current module
      #|
      #|```bash
      #|$ moon ide outline .
      #|spec.mbt:
      #| L003 | pub(all) enum CStandard {
      #|        ...
      #| L013 | pub(all) struct Position {
      #|        ...
      #|```
      #|
      #|```bash
      #|$ moon ide find-references TranslationUnit
      #|```
      #|
      #|## Package Management
      #|
      #|### Adding Dependencies
      #|
      #|```sh
      #|moon add moonbitlang/x        # Add latest version
      #|moon add moonbitlang/x@0.4.6  # Add specific version
      #|```
      #|
      #|### Updating Dependencies
      #|
      #|```sh
      #|moon update                   # Update package index
      #|```
      #|
      #|### Typical Module configurations (`moon.mod.json`)
      #|
      #|```json
      #|{
      #|  "name": "username/hello", // Required format for published modules
      #|  "version": "0.1.0",
      #|  "source": ".", // Source directory(optional, default: ".")
      #|  "repository": "", // Git repository URL
      #|  "keywords": [], // Search keywords
      #|  "description": "...", // Module description
      #|  "deps": {
      #|    // Dependencies from mooncakes.io, using`moon add` to add dependencies
      #|    "moonbitlang/x": "0.4.6"
      #|  }
      #|}
      #|```
      #|
      #|### Typical Package configuration (`moon.pkg.json`)
      #|
      #|```json
      #|{
      #|  "is_main": true,                 // Creates executable when true
      #|  "import": [                      // Package dependencies
      #|    "username/hello/liba",         // Simple import, use @liba.foo() to call functions
      #|    {
      #|      "path": "moonbitlang/x/encoding",
      #|      "alias": "libb"              // Custom alias, use @libb.encode() to call functions
      #|    }
      #|  ],
      #|  "test-import": [...],            // Imports for black-box tests, similar to import
      #|  "wbtest-import": [...]           // Imports for white-box tests, similar to import (rarely used)
      #|}
      #|```
      #|
      #|Packages per directory, packages without `moon.pkg.json` are not recognized.
      #|
      #|### Package Importing (used in moon.pkg.json)
      #|
      #|- **Import format**: `"module_name/package_path"`
      #|- **Usage**: `@alias.function()` to call imported functions
      #|- **Default alias**: Last part of path (e.g., `liba` for `username/hello/liba`)
      #|- **Package reference**: Use `@packagename` in test files to reference the
      #|  tested package
      #|
      #|**Package Alias Rules**:
      #|
      #|- Import `"username/hello/liba"` → use `@liba.function()` (default alias is last path segment)
      #|- Import with custom alias `{"path": "moonbitlang/x/encoding", "alias": "enc"}` → use `@enc.function()`
      #|- In `_test.mbt` or `_wbtest.mbt` files, the package being tested is auto-imported
      #|
      #|Example:
      #|
      #|```mbt
      #|///|
      #|/// In main.mbt after importing "username/hello/liba" in `moon.pkg.json`
      #|fn main {
      #|  println(@liba.hello()) // Calls hello() from liba package
      #|}
      #|```
      #|
      #|### Using Standard Library (moonbitlang/core)
      #|
      #|**MoonBit standard library (moonbitlang/core) packages are automatically imported** - DO NOT add them to dependencies:
      #|
      #|- ❌ **DO NOT** use `moon add` to add standard library packages like `moonbitlang/core/strconv`
      #|- ❌ **DO NOT** add standard library packages to `"deps"` field of `moon.mod.json`
      #|- ❌ **DO NOT** add standard library packages to `"import"` field of `moon.pkg.json`
      #|- ✅ **DO** use them directly: `@strconv.parse_int()`, `@list.List`, `@array.fold()`, etc.
      #|
      #|If you get an error like "cannot import `moonbitlang/core/strconv`", remove it from imports - it's automatically available.
      #|
      #|### Creating Packages
      #|
      #|To add a new package `fib` under `.`:
      #|
      #|1. Create directory: `./fib/`
      #|2. Add `./fib/moon.pkg.json`: `{}` -- Minimal valid moon.pkg.json
      #|3. Add `.mbt` files with your code
      #|4. Import in dependent packages:
      #|
      #|   ```json
      #|   {
      #|     "import": [
      #|        "username/hello/fib",
      #|        ...
      #|     ]
      #|   }
      #|   ```
      #|For more advanced topics like `conditional compilation`, `link configuration`, `warning control`, and `pre-build commands`, see `references/advanced-moonbit-build.md`.
      #|
      #|# MoonBit Language Tour
      #|
      #|## Core facts
      #|
      #|- **Expression‑oriented**: `if`, `match`, loops return values; last expression is the return.
      #|- **References by default**: Arrays/Maps/structs mutate via reference; use `Ref[T]` for primitive mutability.
      #|- **Blocks**: Separate top‑level items with `///|`. Generate code block‑by‑block.
      #|- **Visibility**: `fn` private by default; `pub` exposes read/construct as allowed; `pub(all)` allows external construction.
      #|- **Naming convention**: lower_snake for values/functions; UpperCamel for types/enums; enum variants start UpperCamel.
      #|- **Packages**: No `import` in code files; call via `@alias.fn`. Configure imports in `moon.pkg.json`.
      #|- **Placeholders**: `...` is a valid placeholder in MoonBit code for incomplete implementations.
      #|- **Global values**: immutable by default and generally require type annotations.
      #|- **Garbage collection**: MoonBit has a GC, there is no lifetime annotation, there's no ownership system.
      #|  Unlike Rust, like F#, `let mut` is only needed when you want to reassign a variable, not for mutating fields of a struct or elements of an array/map.
      #|- **Delimit top-level items with `///|` comments** so tools can split the file reliably.
      #|
      #|## MoonBit Error Handling (Checked Errors)
      #|
      #|MoonBit uses checked error-throwing functions, not unchecked exceptions. All errors are subtype of `Error`, we can declare our own error types by `suberror`.
      #|Use `raise` in signatures to declare error types and let errors propagate by
      #|default. Use `try?` to convert to `Result[...]` in tests, or `try { } catch { }`
      #|to handle errors explicitly.
      #|
      #|```mbt check
      #|///|
      #|/// Declare error types with 'suberror'
      #|suberror ValueError String
      #|
      #|///|
      #|/// Tuple struct to hold position info
      #|struct Position(Int, Int) derive(ToJson, Show, Eq) 
      #|
      #|///|
      #|/// ParseError is subtype of Error
      #|pub(all) suberror ParseError {
      #|  InvalidChar(pos~:Position, Char) // pos is labeled
      #|  InvalidEof(pos~:Position)
      #|  InvalidNumber(pos~:Position, String)
      #|  InvalidIdentEscape(pos~:Position)
      #|} derive(Eq, ToJson, Show)
      #|
      #|///|
      #|/// Functions declare what they can throw
      #|fn parse_int(s : String, position~ : Position) -> Int raise ParseError {
      #|  // 'raise' throws an error
      #|  if s is "" {
      #|    raise ParseError::InvalidEof(pos=position)
      #|  }
      #|  ... // parsing logic
      #|}
      #|
      #|///|
      #|/// Just declare `raise` to not track specific error types
      #|fn div(x : Int, y : Int) -> Int raise {
      #|  if y is 0 {
      #|    fail("Division by zero")
      #|  }
      #|  x / y
      #|}
      #|
      #|///|
      #|test "inspect raise function" {
      #|  let result : Result[Int, Error] = try? div(1, 0) 
      #|  guard result is Err(Failure(msg)) && msg.contains("Division by zero") else {
      #|    fail("Expected error")
      #|  }  
      #|}
      #|
      #|// Three ways to handle errors:
      #|
      #|///|
      #|/// Propagate automatically
      #|fn use_parse(position~: Position) -> Int raise ParseError {
      #|  let x = parse_int("123", position=position)
      #|  // Error auto-propagates by default.
      #|  // Unlike Swift, you do not need to mark `try` for functions that can raise
      #|  // errors; the compiler infers it automatically. This keeps error handling
      #|  // explicit but concise.
      #|  x * 2
      #|}
      #|
      #|///|
      #|/// Mark `raise` for all possible errors, do not care which error it is.
      #|/// For quick prototypes, `raise` is acceptable.
      #|fn use_parse2(position~: Position) -> Int raise {
      #|  let x = parse_int("123", position=position)
      #|  x * 2
      #|}
      #|
      #|///|
      #|/// Convert to Result with try?
      #|fn safe_parse(s : String, position~: Position) -> Result[Int, ParseError] {
      #|  let val1 : Result[_] = try? parse_int(s, position=position) // Returns Result[Int, ParseError]
      #|  // try! is rarely used - it panics on error, similar to unwrap() in Rust
      #|  // let val2 : Int = try! parse_int(s) // Returns Int otherwise crash
      #|
      #|  // Alternative explicit handling:
      #|  let val3 = try parse_int(s, position=position) catch {
      #|    err => Err(err)
      #|  } noraise { // noraise block is optional - handles the success case
      #|    v => Ok(v)
      #|  }
      #|  ...
      #|}
      #|
      #|///|
      #|/// Handle with try-catch
      #|fn handle_parse(s : String, position~: Position) -> Int {
      #|  try parse_int(s, position=position) catch {
      #|    ParseError::InvalidEof => {
      #|      println("Parse failed: InvalidEof")
      #|      -1 // Default value
      #|    }
      #|    _ => 2
      #|  }
      #|}
      #|```
      #|
      #|Important: When calling a function that can raise errors, if you only want to
      #|propagate the error, you do not need any marker; the compiler infers it.
      #|
      #|## Integers, Char
      #|
      #|MoonBit supports Byte, Int16, Int, UInt16, UInt, Int64, UInt64, etc. When the type is known,
      #|the literal can be overloaded:
      #|
      #|```mbt check
      #|///|
      #|test "integer and char literal overloading disambiguation via type in the current context" {
      #|  let a0 = 1 // a is Int by default
      #|  let (int, uint, uint16, int64, byte) : (Int, UInt, UInt16, Int64, Byte) = (
      #|    1, 1, 1, 1, 1,
      #|  )
      #|  assert_eq(int, uint16.to_int())
      #|  let a1 : Int = 'b' // this also works, a5 will be the unicode value
      #|  let a2 : Char = 'b'
      #|}
      #|```
      #|## Bytes (Immutable)
      #|
      #|```mbt check
      #|///|
      #|test "bytes literals overloading and indexing" {
      #|  let b0 : Bytes = b"abcd"
      #|  let b1 : Bytes = "abcd" // b" prefix is optional, when we know the type
      #|  let b2 : Bytes = [0xff, 0x00, 0x01] // Array literal overloading
      #|  guard b0 is [b'a', ..] && b0[1] is b'b' else {
      #|    // Bytes can be pattern matched as BytesView and indexed
      #|    fail("unexpected bytes content")
      #|  }
      #|  
      #|}
      #|```
      #|## Array (Resizable)
      #|
      #|```mbt check
      #|///|
      #|test "array literals overloading: disambiguation via type in the current context" {
      #|  let a0 : Array[Int] = [1, 2, 3] // resizable
      #|  let a1 : FixedArray[Int] = [1, 2, 3] // Fixed size
      #|  let a2 : ReadOnlyArray[Int] = [1, 2, 3] 
      #|  let a3 : ArrayView[Int] = [1, 2, 3]
      #|}
      #|```
      #|## String (Immutable UTF-16)
      #|`s[i]` returns a code unit (UInt16), `s.get_char(i)` returns `Char?`.
      #|Since MoonBit supports char literal overloading, you can write code snippets like this:
      #|
      #|```mbt check
      #|///|
      #|test "string indexing and utf8 encode/decode" {
      #|  let s = "hello world"
      #|  let b0 : UInt16 = s[0]
      #|  guard(b0 is ('\n' | 'h' | 'b' | 'a'..='z') && s is [.."hello", ..rest]) else {
      #|    fail("unexpected string content")
      #|  }
      #|  guard rest is " world" // otherwise will crash (guard without else)
      #|  
      #|  // In check mode (expression with explicit type), ('\n' : UInt16) is valid.
      #|  
      #|  // Using get_char for Option handling
      #|  let b1 : Char? = s.get_char(0)
      #|  assert_true(b1 is Some('a'..='z'))
      #|
      #|  // ⚠️ Important: Variables won't work with direct indexing
      #|  let eq_char : Char = '='
      #|  // s[0] == eq_char // ❌ Won't compile - eq_char is not a literal, lhs is UInt while rhs is Char
      #|  // Use: s[0] == '=' or s.get_char(0) == Some(eq_char)
      #|  let bytes = @encoding/utf8.encode("中文") // utf8 encode package is in stdlib
      #|  assert_true(bytes is [0xe4, 0xb8, 0xad, 0xe6, 0x96, 0x87])
      #|  let s2 : String = @encoding/utf8.decode(bytes) // decode utf8 bytes back to String
      #|  assert_true(s2 is "中文")
      #|  for c in "中文" {
      #|    let _ : Char = c // unicode safe iteration  
      #|    println("char: \{c}") // iterate over chars
      #|  }
      #|}
      #|```
      #|
      #|### String Interpolation && StringBuilder
      #|
      #|MoonBit uses `\{}` for string interpolation, for custom types, it needs implement trait `Show`
      #|
      #|```mbt check
      #|///|
      #|test "string interpolation basics" {
      #|
      #|  let name : String = "Moon"
      #|  let config = { "cache": 123 }
      #|  let version = 1.0
      #|  println("Hello \{name} v\{version}") // "Hello Moon v1.0"
      #|  // ❌ Wrong - quotes inside interpolation not allowed:
      #|  // println("  - Checking if 'cache' section exists: \{config["cache"]}")
      #|
      #|  // ✅ Correct - extract to variable first:
      #|  let has_key = config["cache"] // `"` not allowed in interpolation
      #|  println("  - Checking if 'cache' section exists: \{has_key}")
      #|  
      #|  let sb = StringBuilder::new()
      #|  sb..write_char('[') // dotdot for imperative method chaining
      #|    ..write_view([1,2,3].map((x) => "\{x}").join(","))
      #|    ..write_char(']')
      #|  inspect(sb.to_string(), content="[1,2,3]")
      #|}
      #|```
      #|
      #|Expressions inside `\{}` can only be _basic expressions_ (no quotes, newlines, or nested interpolations). String literals are not allowed as it makes lexing too difficult.
      #|
      #|
      #|### Multiple line strings
      #|
      #|```mbt check
      #|///|
      #|test "multi-line string literals" {  
      #|  let multi_line_string : String =
      #|    #|Hello "world"
      #|    #|World
      #|    #|
      #|  let multi_line_string_with_interp : String =
      #|    $|Line 1 ""
      #|    $|Line 2 \{1+2}
      #|    $|
      #|  // no escape in `#|`, 
      #|  // only escape '\{..}` in `$|`
      #|  assert_eq(multi_line_string, "Hello \"world\"\nWorld\n")  
      #|  assert_eq(multi_line_string_with_interp, "Line 1 \"\"\nLine 2 3\n")
      #|}
      #|```
      #|
      #|## Map (Mutable, Insertion-Order Preserving)
      #|
      #|```mbt check
      #|///|
      #|test "map literals and common operations" {
      #|  // Map literal syntax
      #|  let map : Map[String, Int] = { "a": 1, "b": 2, "c": 3 }  
      #|  let empty : Map[String, Int] = {} // Empty map, preferred
      #|  let also_empty : Map[String, Int] = Map::new()
      #|  // From array of pairs
      #|  let from_pairs : Map[String, Int] = Map::from_array([("x", 1), ("y", 2)])
      #|
      #|  // Set/update value
      #|  map["new-key"] = 3
      #|  map["a"] = 10 // Updates existing key
      #|
      #|  // Get value - returns Option[T]
      #|  guard map is { "new-key": 3, "missing"? : None, .. } else {
      #|    fail("unexpected map contents")
      #|  }
      #|
      #|  // Direct access (panics if key missing)
      #|  let value : Int = map["a"] // value = 10
      #|
      #|  // Iteration preserves insertion order
      #|  for k, v in map {
      #|    println("\{k}: \{v}") // Prints: a: 10, b: 2, c: 3, new-key: 3
      #|  }
      #|
      #|  // Other common operations
      #|  map.remove("b")
      #|  guard map is { "a": 10, "c": 3, "new-key": 3, .. } && map.length() == 3 else {
      #|    // "b" is gone, only 3 elements left  
      #|    fail("unexpected map contents after removal")
      #|  }
      #|}
      #|```
      #|
      #|## View Types
      #|
      #|**Key Concept**: View types (`StringView`, `BytesView`, `ArrayView[T]`) are zero-copy, non-owning read-only slices created with the `[:]` syntax. They don't allocate memory and are ideal for passing sub-sequences without copying data, for function which takes String, Bytes, Array, they also take *View(implicit conversion).
      #|
      #|- `String` → `StringView` via `s[:]` or `s[start:end]`
      #|- `Bytes` → `BytesView` via `b[:]` or `b[start:end]`
      #|- `Array[T]`, `FixedArray[T]`, `ReadOnlyArray[T] → `ArrayView[T]` via `a[:]` or `a[start:end]`
      #|
      #|**Important**: StringView slice is slightly different due to unicode safety:
      #|`s[a:b]` may raise an error at surrogate boundaries (UTF-16 encoding edge case). You have two options:
      #|
      #|- Use `try! s[a:b]` if you're certain the boundaries are valid (crashes on invalid boundaries)
      #|- Let the error propagate to the caller for proper handling
      #|
      #|**When to use views**:
      #|
      #|- Pattern matching with rest patterns (`[first, .. rest]`)
      #|- Passing slices to functions without allocation overhead
      #|- Avoiding unnecessary copies of large sequences
      #|
      #|Convert back with `.to_string()`, `.to_bytes()`, or `.to_array()` when you need ownership. (`moon doc StringView`)
      #|
      #|## User defined types(`enum`, `struct`)
      #|
      #|```mbt check
      #|///|
      #|enum Tree[T] {
      #|  Leaf(T) // Unlike Rust, no comma here
      #|  Node(left~ : Tree[T], T, right~ : Tree[T]) // enum can use labels
      #|} derive(Show, ToJson) // derive traits for Tree
      #|
      #|///|
      #|pub fn Tree::sum(tree : Tree[Int]) -> Int {
      #|  match tree {
      #|    Leaf(x) => x 
      #|    // we don't need to write Tree::Leaf, when `tree` has a known type
      #|    Node(left~, x, right~) => left.sum() + x + right.sum() // method invoked in dot notation
      #|  }
      #|}
      #|
      #|///|
      #|struct Point {
      #|  x : Int
      #|  y : Int
      #|} derive(Show, ToJson) // derive traits for Point
      #|
      #|test "user defined types: enum and struct" {
      #|  json_inspect(Point::{ x: 10, y: 20 }, content=({"x":10,"y":20}))
      #|}
      #|
      #|```
      #|
      #|## Functional `for` loop
      #|
      #|
      #|```mbt check
      #|pub fn binary_search(
      #|  arr : ArrayView[Int],
      #|  value : Int,
      #|) -> Result[Int, Int] {
      #|  let len = arr.length()
      #|  // functional for loop:
      #|  // initial state ; [predicate] ; [post-update] {
      #|  // loop body with `continue` to update state
      #|  //} else { // exit block
      #|  // }
      #|  // predicate and post-update are optional
      #|  for i = 0, j = len; i < j; {
      #|    // post-update is omitted, we use `continue` to update state
      #|    let h = i + (j - i) / 2
      #|    if arr[h] < value {
      #|      continue h + 1, j // functional update of loop state
      #|    } else {
      #|      continue i, h // functional update of loop state
      #|    }
      #|  } else { // exit of for loop
      #|    if i < len && arr[i] == value {
      #|      Ok(i)
      #|    } else {
      #|      Err(i)
      #|    }
      #|  }
      #|}
      #|///|
      #|test "functional for loop control flow" {
      #|  let arr : Array[Int] = [1, 3, 5, 7, 9]
      #|  inspect(binary_search(arr,5), content="Ok(2)") // Array to ArrayView implicit conversion when passing as arguments
      #|  inspect(binary_search(arr,6), content="Err(3)")
      #|  // for iteration is supported too
      #|  for i, v in arr {
      #|    println("\{i}: \{v}") // `i` is index, `v` is value
      #|  }
      #|}
      #|```
      #|You are *STRONGLY ENCOURAGED* to use functional `for` loops instead of imperative loops
      #|*WHENEVER POSSIBLE*, as they are easier to reason about.
      #|
      #|## Label and Optional Parameters
      #|
      #|Good example: use labeled and optional parameters
      #|
      #|```mbt check
      #|///|
      #|fn g(
      #|  positional : Int,
      #|  required~ : Int,
      #|  optional? : Int, // no default => Option
      #|  optional_with_default? : Int = 42, // default => plain Int
      #|) -> String {
      #|  // These are the inferred types inside the function body.
      #|  let _ : Int = positional
      #|  let _ : Int = required
      #|  let _ : Int? = optional
      #|  let _ : Int = optional_with_default
      #|  "\{positional},\{required},\{optional},\{optional_with_default}"
      #|}
      #|
      #|///|
      #|test {
      #|  inspect(g(1, required=2), content="1,2,None,42")
      #|  inspect(g(1, required=2, optional=3), content="1,2,Some(3),42")
      #|  inspect(g(1, required=4, optional_with_default=100), content="1,4,None,100")
      #|}
      #|```
      #|
      #|Misuse: `arg : Type?` is not an optional parameter.
      #|Callers still must pass it (as `None`/`Some(...)`).
      #|
      #|```mbt check
      #|///|
      #|fn with_config(a : Int?, b : Int?, c : Int) -> String {
      #|  "\{a},\{b},\{c}"
      #|}
      #|
      #|///|
      #|test {
      #|  inspect(with_config(None, None, 1), content="None,None,1")
      #|  inspect(with_config(Some(5), Some(5), 1), content="Some(5),Some(5),1")
      #|}
      #|```
      #|
      #|Anti-pattern: `arg? : Type?` (no default => double Option).
      #|If you want a defaulted optional parameter, write `b? : Int = 1`, not `b? : Int? = Some(1)`.
      #|
      #|```mbt check
      #|///|
      #|fn f_misuse(a? : Int?, b? : Int = 1) -> Unit {
      #|  let _ : Int?? = a // rarely intended
      #|  let _ : Int = b
      #|
      #|}
      #|// How to fix: declare `(a? : Int, b? : Int = 1)` directly.
      #|
      #|///|
      #|fn f_correct(a? : Int, b? : Int = 1) -> Unit {
      #|  let _ : Int? = a
      #|  let _ : Int = b
      #|
      #|}
      #|
      #|///|
      #|test {
      #|  f_misuse(b=3)
      #|  f_misuse(a=Some(5), b=2) // works but confusing
      #|  f_correct(b=2)
      #|  f_correct(a=5)
      #|}
      #|```
      #|
      #|Bad example: `arg : APIOptions` (use labeled optional parameters instead)
      #|
      #|```mbt check
      #|///|
      #|/// Do not use struct to group options.
      #|struct APIOptions {
      #|  width : Int?
      #|  height : Int?
      #|}
      #|
      #|///|
      #|fn not_idiomatic(opts : APIOptions, arg : Int) -> Unit {
      #|
      #|}
      #|
      #|///|
      #|test {
      #|  // Hard to use in call site
      #|  not_idiomatic({ width : Some(5), height : None }, 10)
      #|  not_idiomatic({ width : None, height : None }, 10)
      #|}
      #|```
      #|
      #|## More details
      #|
      #|For deeper syntax, types, and examples, read `references/moonbit-language-fundamentals.mbt.md`.
    ),
  },
  @assets.Asset::{
    path: "moonbit-agent-guide/SKILL.md",
    content: (
      #|---
      #|name: moonbit-agent-guide
      #|description: Guide for writing, refactoring, and testing MoonBit projects. Use when working in MoonBit modules or packages, organizing MoonBit files, using moon tooling (build/check/test/doc/ide), or following MoonBit-specific layout, documentation, and testing conventions.
      #|---
      #|
      #|# MoonBit Project Layouts
      #|
      #|MoonBit use the `.mbt` extension and interface files `.mbti`. At
      #|the top-level of a MoonBit project there is a `moon.mod.json` file specifying
      #|the metadata of the project. The project may contain multiple packages, each
      #|with its own `moon.pkg.json` file.
      #|
      #|## Example layout
      #|
      #|```
      #|my_module
      #|├── moon.mod.json             # Module metadata, source field(optional) specifies the source directory of the module
      #|├── moon.pkg.json             # Package metadata (each directory is a package like Golang)
      #|├── README.mbt.md             # Markdown with tested code blocks (`test "..." { ... }`)
      #|├── README.md -> README.mbt.md
      #|├── cmd                       # Command line directory
      #|│   └── main
      #|│       ├── main.mbt
      #|│       └── moon.pkg.json     # executable package with {"is_main": true}
      #|├── liba/                     # Library packages
      #|│   └── moon.pkg.json         # Referenced by other packages as `@username/my_module/liba`
      #|│   └── libb/                 # Library packages
      #|│       └── moon.pkg.json     # Referenced by other packages as `@username/my_module/liba/libb`
      #|├── user_pkg.mbt              # Root packages, referenced by other packages as `@username/my_module`
      #|├── user_pkg_wbtest.mbt       # White-box tests (only needed for testing internal private members, similar to Golang's package mypackage)
      #|└── user_pkg_test.mbt         # Black-box tests
      #|└── ...                       # More package files, symbols visible to current package (like Golang)
      #|```
      #|
      #|- **Module**:  `moon.mod.json` file in the project directory.
      #|  A MoonBit *module* is like a Go module,it is a collection of packages in subdirectories, usually corresponding to a repository or project.
      #|  Module boundaries matter for dependency management and import paths.
      #|
      #|- **Package**: a `moon.pkg.json` file per directory. 
      #|  All subcommands of `moon` will
      #|  still be executed in the directory of the module (where `moon.mod.json` is
      #|  located), not the current package.
      #|  A MoonBit *package* is the actual compilation unit (like a Go package).
      #|  All source files in the same package are concatenated into one unit.
      #|  The `package` name in the source defines the package, not the file name.
      #|  Imports refer to module + package paths, NEVER to file names.
      #|
      #|- **Files**:
      #|  A `.mbt` file is just a chunk of source inside a package.
      #|  File names do NOT create modules or namespaces.
      #|  You may freely split/merge/move declarations between files in the same package.
      #|  Any declaration in a package can reference any other declaration in that package, regardless of file.
      #|
      #|
      #|## Coding/layout rules you MUST follow:
      #|
      #|1. Prefer many small, cohesive files over one large file.
      #|   - Group related types and functions into focused files (e.g. http_client.mbt, router.mbt).
      #|   - If a file is getting large or unfocused, create a new file and move related declarations into it.
      #|
      #|2. You MAY freely move declarations between files inside the same package.
      #|   - Each block is separated by `///|`, moving a function/struct/trait between files does not change semantics, as long as its name and pub-ness stay the same, the order of each block is irrelevant too.
      #|   - It is safe to refactor by splitting or merging files inside a package.
      #|
      #|3. File names are purely organizational.
      #|   - Do NOT assume file names define modules, and do NOT use file names in type paths.
      #|   - Choose file names to describe a feature or responsibility, not to mirror type names rigidly.
      #|
      #|4. When adding new code:
      #|   - Prefer adding it to an existing file that matches the feature.
      #|   - If no good file exists, create a new file under the same package with a descriptive name.
      #|   - Avoid creating giant “misc” or “util” files.
      #|
      #|5. Tests:
      #|   - Place tests in dedicated test files (e.g. *_test.mbt) within the appropriate package.
      #|     For a package, besides `*_test.mbt`files,`*.mbt.md`are also blackbox test files, the code block `mbt check` are treated as test cases, they serve both purposes: documentation and tests.      
      #|     You may have `README.mbt.md` files with `mbt check` code examples, you can also symlink `README.mbt.md` to `README.md`
      #|     to make it integrate better with GitHub.
      #|   - It is fine—and encouraged—to have multiple small test files.
      #|
      #|6. Interface files(`pkg.generated.mbti`) 
      #|   `pkg.generated.mbti` is compiler-generated summaries of each package's public API surface. They provide a formal, concise overview of all exported types, functions, and traits without implementation details.
      #|   They are generated using `moon info`, useful for code review, when you have a commit that does not change public APIs, `pkg.generated.mbti` files will remain unchanged, so it is recommended to put `pk.generated.mbti` in version control when you are done.
      #|   
      #|   You can also use `moon doc @moonbitlang/core/strconv` to explore the public API of a package interactively and `moon ide peek-def 'Array::join'` to read
      #|   the definition.
      #|
      #|# Common Pitfalls to Avoid
      #|
      #|- **Don't use uppercase for variables/functions** - compilation error
      #|- **Don't forget `mut` for mutable record fields** - immutable by default
      #|- **Don't ignore error handling** - errors must be explicitly handled
      #|- **Don't use `return` unnecessarily** - last expression is the return value
      #|- **Don't create methods without Type:: prefix** - methods need explicit type prefix
      #|- **Don't forget to handle array bounds** - use `get()` for safe access
      #|- **Don't forget @package prefix when calling functions from other packages**
      #|- **Don't use ++ or -- (not supported)** - use `i = i + 1` or `i += 1`
      #|- **Don't add explicit `try` for error-raising functions** - errors propagate automatically (unlike Swift)
      #|- **Legacy syntax**: Older code may use `function_name!(...)` or `function_name(...)?` - these are deprecated; use normal calls and `try?` for Result conversion
      #|
      #|
      #|# `moon` Essentials
      #|
      #|## Essential Commands
      #|
      #|- `moon new my_project` - Create new project
      #|- `moon run cmd/main` - Run main package
      #|- `moon build` - Build project
      #|- `moon check` - Type check without building, use it REGULARLY, it is fast
      #|- `moon info` - Type check and generate `mbti` files
      #|  run it to see if any public interfaces changed.
      #|- `moon check --target all` - Type check for all backends
      #|- `moon add package` - Add dependency
      #|- `moon remove package` - Remove dependency
      #|- `moon fmt` - Format code
      #|
      #|### Test Commands
      #|
      #|- `moon test` - Run all tests
      #|- `moon test --update` - Update snapshots
      #|- `moon test -v` - Verbose output with test names
      #|- `moon test [dirname|filename]` - Test specific directory or file
      #|- `moon coverage analyze` - Analyze coverage
      #|
      #|
      #|## `README.mbt.md` Generation Guide
      #|
      #|- Output `README.mbt.md` in the package directory. 
      #|  `*.mbt.md` file and docstring contents treats `mbt check` specially.
      #|  `mbt check` block will be included directly as code and also run by `moon check` and `moon test`.  If you don't want the code snippets to be checked, explicit `mbt nocheck` is preferred.
      #|  If you are only referencing types from the package, you should use `mbt nocheck` which will only be syntax highlighted.
      #|  Symlink `README.mbt.md` to `README.md` to adapt to systems that expect `README.md`. 
      #|    
      #|## Testing Guide
      #|
      #|Use snapshot tests as it is easy to update when behavior changes.
      #|
      #|- **Snapshot Tests**: `inspect(value, content="...")`. If unknown, write `inspect(value)` and run `moon test --update` (or `moon test -u`).
      #|  - Use regular `inspect()` for simple values (uses `Show` trait)
      #|  - Use `json_inspect()` for complex nested structures (uses `ToJson` trait, produces more readable output)
      #|  - It is encouraged to `inspect` or `json_inspect` the whole return value of a function if
      #|    the whole return value is not huge, this makes test simple. You need `impl (Show|ToJson) for YourType` or `derive (Show, ToJson)`.
      #|- **Update workflow**: After changing code that affects output, run `moon test --update` to regenerate snapshots, then review the diffs in your test files (the `content=` parameter will be updated automatically).
      #|
      #|- Black-box by default: Call only public APIs via `@package.fn`. Use white-box tests only when private members matter.
      #|- Grouping: Combine related checks in one `test "..." { ... }` block for speed and clarity.
      #|- Panics: Name test with prefix `test "panic ..." {...}`; if the call returns a value, wrap it with `ignore(...)` to silence warnings.
      #|- Errors: Use `try? f()` to get `Result[...]` and `inspect` it when a function may raise.
      #|- Verify: Run `moon test` (or `-u` to update snapshots) and `moon fmt` afterwards.
      #|
      #|### Docstring tests 
      #|
      #|Public APIs are encouraged to have docstring tests.
      #|````mbt check
      #|///|
      #|/// Get the largest element of a non-empty `Array`.
      #|///
      #|/// # Example
      #|/// ```mbt check
      #|/// test {
      #|///   inspect(sum_array([1, 2, 3, 4, 5, 6]), content="21")
      #|/// }
      #|/// ```
      #|///
      #|/// # Panics
      #|/// Panics if the `xs` is empty.
      #|pub fn sum_array(xs : Array[Int]) -> Int {
      #|  xs.fold(init=0, (a, b) => a + b)
      #|}
      #|````
      #|
      #|The MoonBit code in docstring will be type checked and tested automatically.
      #|(using `moon test --update`). In docstrings, `mbt check` should only contain `test` or `async test`.
      #|
      #|## Spec-driven Development
      #|
      #|- The spec can be written in a readonly `spec.mbt` file (name is conventional, not mandatory) with stub code marked as declarations:
      #|
      #|```mbt check
      #|///|
      #|#declaration_only
      #|pub type Yaml
      #|
      #|///|
      #|#declaration_only
      #|pub fn Yaml::to_string(y : Yaml) -> String raise {
      #|  ...
      #|}
      #|
      #|///|
      #|#declaration_only
      #|pub fn parse_yaml(s : String) -> Yaml raise {
      #|  ...
      #|}
      #|```
      #|
      #|- Add `spec_easy_test.mbt`, `spec_difficult_test.mbt` etc to test the spec functions; everything will be type-checked(`moon check`).
      #|- The AI or students can implement the `declaration_only` functions in different files thanks to our package organization.
      #|- Run `moon test` to check everything is correct.
      #|
      #|- `#declaration_only` is supported for functions, methods, and types.
      #|- The `pub type Yaml` line is an intentionally opaque placeholder; the implementer chooses its representation.
      #|- Note the spec file can also contain normal code, not just declarations.
      #|
      #|## `moon doc` for API Discovery
      #|
      #|**CRITICAL**: `moon doc '<query>'` is your PRIMARY tool for discovering available APIs, functions, types, and methods in MoonBit. Always prefer `moon doc` over other approaches when exploring what APIs are available, it is **more powerful and accurate** than `grep_search` or any regex-based searching tools. 
      #|
      #|
      #|`moon doc` uses a specialized query syntax designed for symbol lookup:
      #|- **Empty query**: `moon doc ''`
      #|
      #|  - In a module: shows all available packages in current module, including dependencies and moonbitlang/core
      #|  - In a package: shows all symbols in current package
      #|  - Outside package: shows all available packages
      #|
      #|- **Function/value lookup**: `moon doc "[@pkg.]value_or_function_name"`
      #|  
      #|- **Type lookup**: `moon doc "[@pkg.]Type_name"` (builtin type does not need package prefix)
      #|
      #|- **Method/field lookup**: `moon doc "[@pkg.]Type_name::method_or_field_name"`
      #|
      #|- **Package exploration**: `moon doc "@pkg"`
      #|  - Show package `pkg` and list all its exported symbols
      #|  - Example: `moon doc "@json"` - explore entire `@json` package
      #|  - Example: `moon doc "@encoding/utf8"` - explore nested package
      #|
      #|- **Globbing**: Use `*` wildcard for partial matches, e.g. `moon doc "String::*rev*"` to find all String methods with "rev" in their name
      #|
      #|### `moon doc` Examples
      #|
      #|````bash
      #|# search for String methods in standard library:
      #|$ moon doc "String"
      #|
      #|type String
      #|
      #|  pub fn String::add(String, String) -> String
      #|  # ... more methods omitted ...
      #|
      #|$ moon doc "@buffer" # list all symbols in  package buffer:
      #|moonbitlang/core/buffer
      #|
      #|fn from_array(ArrayView[Byte]) -> Buffer
      #|# ... omitted ...
      #|
      #|$ moon doc "@buffer.new" # list the specific function in a package:
      #|package "moonbitlang/core/buffer"
      #|
      #|pub fn new(size_hint? : Int) -> Buffer
      #|  Creates ... omitted ...
      #|
      #|
      #|$ moon doc "String::*rev*"  # globbing
      #|package "moonbitlang/core/string"
      #|
      #|pub fn String::rev(String) -> String
      #|  Returns ... omitted ...
      #|  # ... more
      #|
      #|pub fn String::rev_find(String, StringView) -> Int?
      #|  Returns ... omitted ...
      #|````
      #|**Best practice**: When implementing a feature, start with `moon doc` queries to discover available APIs before writing code. This is faster and more accurate than searching through files.
      #|
      #|## `moon ide [peek-def|outline|find-references]` for code navigation and refactoring
      #|
      #|For project-local symbols and navigation, use `moon ide outline .` to scan a package, `moon ide find-references <symbol>` to locate usages, and `moon ide peek-def` for inline definition context and locate toplevel symbols. 
      #|
      #|These tools save tokens and more precise than grepping(grep display results in both definition and call site including comments too).
      #|
      #|### `moon ide peek-def sym [-loc filename:line:col]` example
      #|
      #|When the user ask: Can you check if `Parser::read_u32_leb128` is implemented correctly?
      #|
      #|In this case, You can run `moon ide peek-def Parser::read_u32_leb128` to get the definition context: (this is better than `grep` since it searches the whole project by semantics)
      #|
      #|``` file src/parse.mbt
      #|L45:|///|
      #|L46:|fn Parser::read_u32_leb128(self : Parser) -> UInt raise ParseError {
      #|L47:|  ...
      #|...:| }
      #|```
      #|Now you want to see the definition of `Parser` struct, you can run:
      #|
      #|```bash
      #|$ moon ide peek-def Parser -loc src/parse.mbt:46:4
      #|Definition found at file src/parse.mbt
      #|  | ///|
      #|2 | priv struct Parser {
      #|  |             ^^^^^^
      #|  |   bytes : Bytes
      #|  |   mut pos : Int
      #|  | }  
      #|  | 
      #|```
      #|For the `-loc` argument, the line number must be precise; the column can be approximate since 
      #|the positonal argument `Parser` helps locate the position.
      #|
      #|If the sym is toplevel symbol, the location can be omitted:
      #|````bash
      #|$ moon ide peek-def String::rev
      #|Found 1 symbols matching 'String::rev':
      #|
      #|`pub fn String::rev` in package moonbitlang/core/builtin at /Users/usrname/.moon/lib/core/builtin/string_methods.mbt:1039-1044
      #|1039 | ///|
      #|     | /// Returns a new string with the characters in reverse order. It respects
      #|     | /// Unicode characters and surrogate pairs but not grapheme clusters.
      #|     | pub fn String::rev(self : String) -> String {
      #|     |   self[:].rev()
      #|     | }         
      #|````
      #|
      #|### `moon ide outline [dir|file]` and `moon ide find-references <sym>` for Package Symbols
      #|
      #|Use this to scan a package or file for top-level symbols and locate usages without grepping
      #|
      #|- `moon ide outline dir` outlines the current package directory (per-file headers)
      #|- `moon ide outline parser.mbt` outlines a single file
      #|- Useful when you need a quick inventory of a package, or to find the right file before `goto-definition`
      #|- `moon ide find-references TranslationUnit` finds all references to a symbol in the current module
      #|
      #|```bash
      #|$ moon ide outline .
      #|spec.mbt:
      #| L003 | pub(all) enum CStandard {
      #|        ...
      #| L013 | pub(all) struct Position {
      #|        ...
      #|```
      #|
      #|```bash
      #|$ moon ide find-references TranslationUnit
      #|```
      #|
      #|## Package Management
      #|
      #|### Adding Dependencies
      #|
      #|```sh
      #|moon add moonbitlang/x        # Add latest version
      #|moon add moonbitlang/x@0.4.6  # Add specific version
      #|```
      #|
      #|### Updating Dependencies
      #|
      #|```sh
      #|moon update                   # Update package index
      #|```
      #|
      #|### Typical Module configurations (`moon.mod.json`)
      #|
      #|```json
      #|{
      #|  "name": "username/hello", // Required format for published modules
      #|  "version": "0.1.0",
      #|  "source": ".", // Source directory(optional, default: ".")
      #|  "repository": "", // Git repository URL
      #|  "keywords": [], // Search keywords
      #|  "description": "...", // Module description
      #|  "deps": {
      #|    // Dependencies from mooncakes.io, using`moon add` to add dependencies
      #|    "moonbitlang/x": "0.4.6"
      #|  }
      #|}
      #|```
      #|
      #|### Typical Package configuration (`moon.pkg.json`)
      #|
      #|```json
      #|{
      #|  "is_main": true,                 // Creates executable when true
      #|  "import": [                      // Package dependencies
      #|    "username/hello/liba",         // Simple import, use @liba.foo() to call functions
      #|    {
      #|      "path": "moonbitlang/x/encoding",
      #|      "alias": "libb"              // Custom alias, use @libb.encode() to call functions
      #|    }
      #|  ],
      #|  "test-import": [...],            // Imports for black-box tests, similar to import
      #|  "wbtest-import": [...]           // Imports for white-box tests, similar to import (rarely used)
      #|}
      #|```
      #|
      #|Packages per directory, packages without `moon.pkg.json` are not recognized.
      #|
      #|### Package Importing (used in moon.pkg.json)
      #|
      #|- **Import format**: `"module_name/package_path"`
      #|- **Usage**: `@alias.function()` to call imported functions
      #|- **Default alias**: Last part of path (e.g., `liba` for `username/hello/liba`)
      #|- **Package reference**: Use `@packagename` in test files to reference the
      #|  tested package
      #|
      #|**Package Alias Rules**:
      #|
      #|- Import `"username/hello/liba"` → use `@liba.function()` (default alias is last path segment)
      #|- Import with custom alias `{"path": "moonbitlang/x/encoding", "alias": "enc"}` → use `@enc.function()`
      #|- In `_test.mbt` or `_wbtest.mbt` files, the package being tested is auto-imported
      #|
      #|Example:
      #|
      #|```mbt
      #|///|
      #|/// In main.mbt after importing "username/hello/liba" in `moon.pkg.json`
      #|fn main {
      #|  println(@liba.hello()) // Calls hello() from liba package
      #|}
      #|```
      #|
      #|### Using Standard Library (moonbitlang/core)
      #|
      #|**MoonBit standard library (moonbitlang/core) packages are automatically imported** - DO NOT add them to dependencies:
      #|
      #|- ❌ **DO NOT** use `moon add` to add standard library packages like `moonbitlang/core/strconv`
      #|- ❌ **DO NOT** add standard library packages to `"deps"` field of `moon.mod.json`
      #|- ❌ **DO NOT** add standard library packages to `"import"` field of `moon.pkg.json`
      #|- ✅ **DO** use them directly: `@strconv.parse_int()`, `@list.List`, `@array.fold()`, etc.
      #|
      #|If you get an error like "cannot import `moonbitlang/core/strconv`", remove it from imports - it's automatically available.
      #|
      #|### Creating Packages
      #|
      #|To add a new package `fib` under `.`:
      #|
      #|1. Create directory: `./fib/`
      #|2. Add `./fib/moon.pkg.json`: `{}` -- Minimal valid moon.pkg.json
      #|3. Add `.mbt` files with your code
      #|4. Import in dependent packages:
      #|
      #|   ```json
      #|   {
      #|     "import": [
      #|        "username/hello/fib",
      #|        ...
      #|     ]
      #|   }
      #|   ```
      #|For more advanced topics like `conditional compilation`, `link configuration`, `warning control`, and `pre-build commands`, see `references/advanced-moonbit-build.md`.
      #|
      #|# MoonBit Language Tour
      #|
      #|## Core facts
      #|
      #|- **Expression‑oriented**: `if`, `match`, loops return values; last expression is the return.
      #|- **References by default**: Arrays/Maps/structs mutate via reference; use `Ref[T]` for primitive mutability.
      #|- **Blocks**: Separate top‑level items with `///|`. Generate code block‑by‑block.
      #|- **Visibility**: `fn` private by default; `pub` exposes read/construct as allowed; `pub(all)` allows external construction.
      #|- **Naming convention**: lower_snake for values/functions; UpperCamel for types/enums; enum variants start UpperCamel.
      #|- **Packages**: No `import` in code files; call via `@alias.fn`. Configure imports in `moon.pkg.json`.
      #|- **Placeholders**: `...` is a valid placeholder in MoonBit code for incomplete implementations.
      #|- **Global values**: immutable by default and generally require type annotations.
      #|- **Garbage collection**: MoonBit has a GC, there is no lifetime annotation, there's no ownership system.
      #|  Unlike Rust, like F#, `let mut` is only needed when you want to reassign a variable, not for mutating fields of a struct or elements of an array/map.
      #|- **Delimit top-level items with `///|` comments** so tools can split the file reliably.
      #|
      #|## MoonBit Error Handling (Checked Errors)
      #|
      #|MoonBit uses checked error-throwing functions, not unchecked exceptions. All errors are subtype of `Error`, we can declare our own error types by `suberror`.
      #|Use `raise` in signatures to declare error types and let errors propagate by
      #|default. Use `try?` to convert to `Result[...]` in tests, or `try { } catch { }`
      #|to handle errors explicitly.
      #|
      #|```mbt check
      #|///|
      #|/// Declare error types with 'suberror'
      #|suberror ValueError String
      #|
      #|///|
      #|/// Tuple struct to hold position info
      #|struct Position(Int, Int) derive(ToJson, Show, Eq) 
      #|
      #|///|
      #|/// ParseError is subtype of Error
      #|pub(all) suberror ParseError {
      #|  InvalidChar(pos~:Position, Char) // pos is labeled
      #|  InvalidEof(pos~:Position)
      #|  InvalidNumber(pos~:Position, String)
      #|  InvalidIdentEscape(pos~:Position)
      #|} derive(Eq, ToJson, Show)
      #|
      #|///|
      #|/// Functions declare what they can throw
      #|fn parse_int(s : String, position~ : Position) -> Int raise ParseError {
      #|  // 'raise' throws an error
      #|  if s is "" {
      #|    raise ParseError::InvalidEof(pos=position)
      #|  }
      #|  ... // parsing logic
      #|}
      #|
      #|///|
      #|/// Just declare `raise` to not track specific error types
      #|fn div(x : Int, y : Int) -> Int raise {
      #|  if y is 0 {
      #|    fail("Division by zero")
      #|  }
      #|  x / y
      #|}
      #|
      #|///|
      #|test "inspect raise function" {
      #|  let result : Result[Int, Error] = try? div(1, 0) 
      #|  guard result is Err(Failure(msg)) && msg.contains("Division by zero") else {
      #|    fail("Expected error")
      #|  }  
      #|}
      #|
      #|// Three ways to handle errors:
      #|
      #|///|
      #|/// Propagate automatically
      #|fn use_parse(position~: Position) -> Int raise ParseError {
      #|  let x = parse_int("123", position=position)
      #|  // Error auto-propagates by default.
      #|  // Unlike Swift, you do not need to mark `try` for functions that can raise
      #|  // errors; the compiler infers it automatically. This keeps error handling
      #|  // explicit but concise.
      #|  x * 2
      #|}
      #|
      #|///|
      #|/// Mark `raise` for all possible errors, do not care which error it is.
      #|/// For quick prototypes, `raise` is acceptable.
      #|fn use_parse2(position~: Position) -> Int raise {
      #|  let x = parse_int("123", position=position)
      #|  x * 2
      #|}
      #|
      #|///|
      #|/// Convert to Result with try?
      #|fn safe_parse(s : String, position~: Position) -> Result[Int, ParseError] {
      #|  let val1 : Result[_] = try? parse_int(s, position=position) // Returns Result[Int, ParseError]
      #|  // try! is rarely used - it panics on error, similar to unwrap() in Rust
      #|  // let val2 : Int = try! parse_int(s) // Returns Int otherwise crash
      #|
      #|  // Alternative explicit handling:
      #|  let val3 = try parse_int(s, position=position) catch {
      #|    err => Err(err)
      #|  } noraise { // noraise block is optional - handles the success case
      #|    v => Ok(v)
      #|  }
      #|  ...
      #|}
      #|
      #|///|
      #|/// Handle with try-catch
      #|fn handle_parse(s : String, position~: Position) -> Int {
      #|  try parse_int(s, position=position) catch {
      #|    ParseError::InvalidEof => {
      #|      println("Parse failed: InvalidEof")
      #|      -1 // Default value
      #|    }
      #|    _ => 2
      #|  }
      #|}
      #|```
      #|
      #|Important: When calling a function that can raise errors, if you only want to
      #|propagate the error, you do not need any marker; the compiler infers it.
      #|
      #|## Integers, Char
      #|
      #|MoonBit supports Byte, Int16, Int, UInt16, UInt, Int64, UInt64, etc. When the type is known,
      #|the literal can be overloaded:
      #|
      #|```mbt check
      #|///|
      #|test "integer and char literal overloading disambiguation via type in the current context" {
      #|  let a0 = 1 // a is Int by default
      #|  let (int, uint, uint16, int64, byte) : (Int, UInt, UInt16, Int64, Byte) = (
      #|    1, 1, 1, 1, 1,
      #|  )
      #|  assert_eq(int, uint16.to_int())
      #|  let a1 : Int = 'b' // this also works, a5 will be the unicode value
      #|  let a2 : Char = 'b'
      #|}
      #|```
      #|## Bytes (Immutable)
      #|
      #|```mbt check
      #|///|
      #|test "bytes literals overloading and indexing" {
      #|  let b0 : Bytes = b"abcd"
      #|  let b1 : Bytes = "abcd" // b" prefix is optional, when we know the type
      #|  let b2 : Bytes = [0xff, 0x00, 0x01] // Array literal overloading
      #|  guard b0 is [b'a', ..] && b0[1] is b'b' else {
      #|    // Bytes can be pattern matched as BytesView and indexed
      #|    fail("unexpected bytes content")
      #|  }
      #|  
      #|}
      #|```
      #|## Array (Resizable)
      #|
      #|```mbt check
      #|///|
      #|test "array literals overloading: disambiguation via type in the current context" {
      #|  let a0 : Array[Int] = [1, 2, 3] // resizable
      #|  let a1 : FixedArray[Int] = [1, 2, 3] // Fixed size
      #|  let a2 : ReadOnlyArray[Int] = [1, 2, 3] 
      #|  let a3 : ArrayView[Int] = [1, 2, 3]
      #|}
      #|```
      #|## String (Immutable UTF-16)
      #|`s[i]` returns a code unit (UInt16), `s.get_char(i)` returns `Char?`.
      #|Since MoonBit supports char literal overloading, you can write code snippets like this:
      #|
      #|```mbt check
      #|///|
      #|test "string indexing and utf8 encode/decode" {
      #|  let s = "hello world"
      #|  let b0 : UInt16 = s[0]
      #|  guard(b0 is ('\n' | 'h' | 'b' | 'a'..='z') && s is [.."hello", ..rest]) else {
      #|    fail("unexpected string content")
      #|  }
      #|  guard rest is " world" // otherwise will crash (guard without else)
      #|  
      #|  // In check mode (expression with explicit type), ('\n' : UInt16) is valid.
      #|  
      #|  // Using get_char for Option handling
      #|  let b1 : Char? = s.get_char(0)
      #|  assert_true(b1 is Some('a'..='z'))
      #|
      #|  // ⚠️ Important: Variables won't work with direct indexing
      #|  let eq_char : Char = '='
      #|  // s[0] == eq_char // ❌ Won't compile - eq_char is not a literal, lhs is UInt while rhs is Char
      #|  // Use: s[0] == '=' or s.get_char(0) == Some(eq_char)
      #|  let bytes = @encoding/utf8.encode("中文") // utf8 encode package is in stdlib
      #|  assert_true(bytes is [0xe4, 0xb8, 0xad, 0xe6, 0x96, 0x87])
      #|  let s2 : String = @encoding/utf8.decode(bytes) // decode utf8 bytes back to String
      #|  assert_true(s2 is "中文")
      #|  for c in "中文" {
      #|    let _ : Char = c // unicode safe iteration  
      #|    println("char: \{c}") // iterate over chars
      #|  }
      #|}
      #|```
      #|
      #|### String Interpolation && StringBuilder
      #|
      #|MoonBit uses `\{}` for string interpolation, for custom types, it needs implement trait `Show`
      #|
      #|```mbt check
      #|///|
      #|test "string interpolation basics" {
      #|
      #|  let name : String = "Moon"
      #|  let config = { "cache": 123 }
      #|  let version = 1.0
      #|  println("Hello \{name} v\{version}") // "Hello Moon v1.0"
      #|  // ❌ Wrong - quotes inside interpolation not allowed:
      #|  // println("  - Checking if 'cache' section exists: \{config["cache"]}")
      #|
      #|  // ✅ Correct - extract to variable first:
      #|  let has_key = config["cache"] // `"` not allowed in interpolation
      #|  println("  - Checking if 'cache' section exists: \{has_key}")
      #|  
      #|  let sb = StringBuilder::new()
      #|  sb..write_char('[') // dotdot for imperative method chaining
      #|    ..write_view([1,2,3].map((x) => "\{x}").join(","))
      #|    ..write_char(']')
      #|  inspect(sb.to_string(), content="[1,2,3]")
      #|}
      #|```
      #|
      #|Expressions inside `\{}` can only be _basic expressions_ (no quotes, newlines, or nested interpolations). String literals are not allowed as it makes lexing too difficult.
      #|
      #|
      #|### Multiple line strings
      #|
      #|```mbt check
      #|///|
      #|test "multi-line string literals" {  
      #|  let multi_line_string : String =
      #|    #|Hello "world"
      #|    #|World
      #|    #|
      #|  let multi_line_string_with_interp : String =
      #|    $|Line 1 ""
      #|    $|Line 2 \{1+2}
      #|    $|
      #|  // no escape in `#|`, 
      #|  // only escape '\{..}` in `$|`
      #|  assert_eq(multi_line_string, "Hello \"world\"\nWorld\n")  
      #|  assert_eq(multi_line_string_with_interp, "Line 1 \"\"\nLine 2 3\n")
      #|}
      #|```
      #|
      #|## Map (Mutable, Insertion-Order Preserving)
      #|
      #|```mbt check
      #|///|
      #|test "map literals and common operations" {
      #|  // Map literal syntax
      #|  let map : Map[String, Int] = { "a": 1, "b": 2, "c": 3 }  
      #|  let empty : Map[String, Int] = {} // Empty map, preferred
      #|  let also_empty : Map[String, Int] = Map::new()
      #|  // From array of pairs
      #|  let from_pairs : Map[String, Int] = Map::from_array([("x", 1), ("y", 2)])
      #|
      #|  // Set/update value
      #|  map["new-key"] = 3
      #|  map["a"] = 10 // Updates existing key
      #|
      #|  // Get value - returns Option[T]
      #|  guard map is { "new-key": 3, "missing"? : None, .. } else {
      #|    fail("unexpected map contents")
      #|  }
      #|
      #|  // Direct access (panics if key missing)
      #|  let value : Int = map["a"] // value = 10
      #|
      #|  // Iteration preserves insertion order
      #|  for k, v in map {
      #|    println("\{k}: \{v}") // Prints: a: 10, b: 2, c: 3, new-key: 3
      #|  }
      #|
      #|  // Other common operations
      #|  map.remove("b")
      #|  guard map is { "a": 10, "c": 3, "new-key": 3, .. } && map.length() == 3 else {
      #|    // "b" is gone, only 3 elements left  
      #|    fail("unexpected map contents after removal")
      #|  }
      #|}
      #|```
      #|
      #|## View Types
      #|
      #|**Key Concept**: View types (`StringView`, `BytesView`, `ArrayView[T]`) are zero-copy, non-owning read-only slices created with the `[:]` syntax. They don't allocate memory and are ideal for passing sub-sequences without copying data, for function which takes String, Bytes, Array, they also take *View(implicit conversion).
      #|
      #|- `String` → `StringView` via `s[:]` or `s[start:end]`
      #|- `Bytes` → `BytesView` via `b[:]` or `b[start:end]`
      #|- `Array[T]`, `FixedArray[T]`, `ReadOnlyArray[T] → `ArrayView[T]` via `a[:]` or `a[start:end]`
      #|
      #|**Important**: StringView slice is slightly different due to unicode safety:
      #|`s[a:b]` may raise an error at surrogate boundaries (UTF-16 encoding edge case). You have two options:
      #|
      #|- Use `try! s[a:b]` if you're certain the boundaries are valid (crashes on invalid boundaries)
      #|- Let the error propagate to the caller for proper handling
      #|
      #|**When to use views**:
      #|
      #|- Pattern matching with rest patterns (`[first, .. rest]`)
      #|- Passing slices to functions without allocation overhead
      #|- Avoiding unnecessary copies of large sequences
      #|
      #|Convert back with `.to_string()`, `.to_bytes()`, or `.to_array()` when you need ownership. (`moon doc StringView`)
      #|
      #|## User defined types(`enum`, `struct`)
      #|
      #|```mbt check
      #|///|
      #|enum Tree[T] {
      #|  Leaf(T) // Unlike Rust, no comma here
      #|  Node(left~ : Tree[T], T, right~ : Tree[T]) // enum can use labels
      #|} derive(Show, ToJson) // derive traits for Tree
      #|
      #|///|
      #|pub fn Tree::sum(tree : Tree[Int]) -> Int {
      #|  match tree {
      #|    Leaf(x) => x 
      #|    // we don't need to write Tree::Leaf, when `tree` has a known type
      #|    Node(left~, x, right~) => left.sum() + x + right.sum() // method invoked in dot notation
      #|  }
      #|}
      #|
      #|///|
      #|struct Point {
      #|  x : Int
      #|  y : Int
      #|} derive(Show, ToJson) // derive traits for Point
      #|
      #|test "user defined types: enum and struct" {
      #|  json_inspect(Point::{ x: 10, y: 20 }, content=({"x":10,"y":20}))
      #|}
      #|
      #|```
      #|
      #|## Functional `for` loop
      #|
      #|
      #|```mbt check
      #|pub fn binary_search(
      #|  arr : ArrayView[Int],
      #|  value : Int,
      #|) -> Result[Int, Int] {
      #|  let len = arr.length()
      #|  // functional for loop:
      #|  // initial state ; [predicate] ; [post-update] {
      #|  // loop body with `continue` to update state
      #|  //} else { // exit block
      #|  // }
      #|  // predicate and post-update are optional
      #|  for i = 0, j = len; i < j; {
      #|    // post-update is omitted, we use `continue` to update state
      #|    let h = i + (j - i) / 2
      #|    if arr[h] < value {
      #|      continue h + 1, j // functional update of loop state
      #|    } else {
      #|      continue i, h // functional update of loop state
      #|    }
      #|  } else { // exit of for loop
      #|    if i < len && arr[i] == value {
      #|      Ok(i)
      #|    } else {
      #|      Err(i)
      #|    }
      #|  }
      #|}
      #|///|
      #|test "functional for loop control flow" {
      #|  let arr : Array[Int] = [1, 3, 5, 7, 9]
      #|  inspect(binary_search(arr,5), content="Ok(2)") // Array to ArrayView implicit conversion when passing as arguments
      #|  inspect(binary_search(arr,6), content="Err(3)")
      #|  // for iteration is supported too
      #|  for i, v in arr {
      #|    println("\{i}: \{v}") // `i` is index, `v` is value
      #|  }
      #|}
      #|```
      #|You are *STRONGLY ENCOURAGED* to use functional `for` loops instead of imperative loops
      #|*WHENEVER POSSIBLE*, as they are easier to reason about.
      #|
      #|## Label and Optional Parameters
      #|
      #|Good example: use labeled and optional parameters
      #|
      #|```mbt check
      #|///|
      #|fn g(
      #|  positional : Int,
      #|  required~ : Int,
      #|  optional? : Int, // no default => Option
      #|  optional_with_default? : Int = 42, // default => plain Int
      #|) -> String {
      #|  // These are the inferred types inside the function body.
      #|  let _ : Int = positional
      #|  let _ : Int = required
      #|  let _ : Int? = optional
      #|  let _ : Int = optional_with_default
      #|  "\{positional},\{required},\{optional},\{optional_with_default}"
      #|}
      #|
      #|///|
      #|test {
      #|  inspect(g(1, required=2), content="1,2,None,42")
      #|  inspect(g(1, required=2, optional=3), content="1,2,Some(3),42")
      #|  inspect(g(1, required=4, optional_with_default=100), content="1,4,None,100")
      #|}
      #|```
      #|
      #|Misuse: `arg : Type?` is not an optional parameter.
      #|Callers still must pass it (as `None`/`Some(...)`).
      #|
      #|```mbt check
      #|///|
      #|fn with_config(a : Int?, b : Int?, c : Int) -> String {
      #|  "\{a},\{b},\{c}"
      #|}
      #|
      #|///|
      #|test {
      #|  inspect(with_config(None, None, 1), content="None,None,1")
      #|  inspect(with_config(Some(5), Some(5), 1), content="Some(5),Some(5),1")
      #|}
      #|```
      #|
      #|Anti-pattern: `arg? : Type?` (no default => double Option).
      #|If you want a defaulted optional parameter, write `b? : Int = 1`, not `b? : Int? = Some(1)`.
      #|
      #|```mbt check
      #|///|
      #|fn f_misuse(a? : Int?, b? : Int = 1) -> Unit {
      #|  let _ : Int?? = a // rarely intended
      #|  let _ : Int = b
      #|
      #|}
      #|// How to fix: declare `(a? : Int, b? : Int = 1)` directly.
      #|
      #|///|
      #|fn f_correct(a? : Int, b? : Int = 1) -> Unit {
      #|  let _ : Int? = a
      #|  let _ : Int = b
      #|
      #|}
      #|
      #|///|
      #|test {
      #|  f_misuse(b=3)
      #|  f_misuse(a=Some(5), b=2) // works but confusing
      #|  f_correct(b=2)
      #|  f_correct(a=5)
      #|}
      #|```
      #|
      #|Bad example: `arg : APIOptions` (use labeled optional parameters instead)
      #|
      #|```mbt check
      #|///|
      #|/// Do not use struct to group options.
      #|struct APIOptions {
      #|  width : Int?
      #|  height : Int?
      #|}
      #|
      #|///|
      #|fn not_idiomatic(opts : APIOptions, arg : Int) -> Unit {
      #|
      #|}
      #|
      #|///|
      #|test {
      #|  // Hard to use in call site
      #|  not_idiomatic({ width : Some(5), height : None }, 10)
      #|  not_idiomatic({ width : None, height : None }, 10)
      #|}
      #|```
      #|
      #|## More details
      #|
      #|For deeper syntax, types, and examples, read `references/moonbit-language-fundamentals.mbt.md`.
    ),
  },
  @assets.Asset::{
    path: "moonbit-agent-guide/ide.md",
    content: (
      #|## Code Navigation with `moon ide`
      #|
      #|**ALWAYS use `moon ide` for code navigation in MoonBit projects instead of manual file searching, grep, or semantic search.**
      #|
      #|This tool provides two essential commands for precise code exploration:
      #|
      #|### Core Commands
      #|
      #|- `moon ide goto-definition` - Find where a symbol is defined
      #|- `moon ide find-references` - Find all usages of a symbol
      #|
      #|### Query System
      #|
      #|Symbol lookup uses a two-part query system for precise results:
      #|
      #|#### 1. Symbol Name Query (`-query`)
      #|
      #|Fuzzy search for symbol names with package filtering support:
      #|
      #|```bash
      #|# Find any symbol named 'symbol'
      #|moon ide goto-definition -query 'symbol'
      #|
      #|# Find methods of a specific type
      #|moon ide goto-definition -query 'Type::method'
      #|
      #|# Find trait method implementations
      #|moon ide goto-definition -query 'Trait for Type with method'
      #|
      #|# Find symbol in specific package using @pkg prefix
      #|moon ide goto-definition -query '@moonbitlang/x encode'
      #|
      #|# Find symbol in multiple packages (searches in pkg1 OR pkg2)
      #|moon ide goto-definition -query '@username/mymodule/pkg1 @username/mymodule/pkg2 helper'
      #|
      #|# Find symbol in nested package
      #|moon ide goto-definition -query '@username/mymodule/mypkg helper'
      #|```
      #|
      #|**Supported symbols**: functions, constants, let bindings, types, structs, enums, traits
      #|
      #|**Package filtering**: Prefix your query with `@package_name` to scope the search. Multiple `@pkg` prefixes create an OR condition.
      #|
      #|#### 2. Tag-based Filtering (`-tags`)
      #|
      #|Pre-filter symbols by characteristics before name matching:
      #|
      #|**Visibility tags**:
      #|
      #|- `pub` - Public symbols
      #|- `pub all` - Public structs with all public fields
      #|- `pub open` - Public traits with all methods public
      #|- `priv` - Private symbols
      #|
      #|**Symbol type tags**:
      #|
      #|- `type` - Type definitions (struct, enum, typealias, abstract)
      #|- `error` - Error type definitions
      #|- `enum` - Enum definitions and variants
      #|- `struct` - Struct definitions
      #|- `alias` - Type/function/trait aliases
      #|- `let` - Top-level let bindings
      #|- `const` - Constant definitions
      #|- `fn` - Function definitions
      #|- `trait` - Trait definitions
      #|- `impl` - Trait implementations
      #|- `test` - Named test functions
      #|
      #|**Combine tags with logical operators**:
      #|
      #|```bash
      #|# Public functions only
      #|moon ide goto-definition -tags 'pub fn' -query 'my_func'
      #|
      #|# Functions or constants
      #|moon ide goto-definition -tags 'fn | const' -query 'helper'
      #|
      #|# Public functions or constants
      #|moon ide goto-definition -tags 'pub (fn | const)' -query 'api'
      #|
      #|# Public types or traits
      #|moon ide goto-definition -tags 'pub (type | trait)' -query 'MyType'
      #|```
      #|
      #|### Practical Examples
      #|
      #|```bash
      #|# Find public function definition
      #|moon ide goto-definition -tags 'pub fn' -query 'maximum'
      #|
      #|# Find all references to a struct
      #|moon ide find-references -tags 'struct' -query 'Rectangle'
      #|
      #|# Find trait implementations
      #|moon ide goto-definition -tags 'impl' -query 'Show for MyType'
      #|
      #|# Find errors in specific package
      #|moon ide goto-definition -tags 'error' -query '@mymodule/parser ParseError'
      #|
      #|# Find symbol across multiple packages
      #|moon ide goto-definition -query '@moonbitlang/x @moonbitlang/core encode'
      #|
      #|# Combine package filtering with tags
      #|moon ide goto-definition -tags 'pub fn' -query '@username/myapp helper'
      #|```
      #|
      #|### Query Processing
      #|
      #|The tool processes queries in this order:
      #|
      #|1. Filter symbols by `-tags` conditions
      #|2. Extract package scope from `@pkg` prefixes in `-query`
      #|3. Fuzzy match remaining symbols by name
      #|4. Return top 3 best matches with location information
      #|
      #|**Best Practice**: Start with `-tags` to reduce noise, then use `@pkg` prefixes in `-query` to scope by package for precise navigation.
    ),
  },
  @assets.Asset::{
    path: "moonbit-agent-guide/references/advanced-moonbit-build.md",
    content: (
      #|## Conditional Compilation
      #|
      #|Target specific backends/modes in `moon.pkg.json`:
      #|
      #|```json
      #|{
      #|  "targets": {
      #|    "wasm_only.mbt": ["wasm"],
      #|    "js_only.mbt": ["js"],
      #|    "debug_only.mbt": ["debug"],
      #|    "wasm_or_js.mbt": ["wasm", "js"], // for wasm or js backend
      #|    "not_js.mbt": ["not", "js"], // for nonjs backend
      #|    "complex.mbt": ["or", ["and", "wasm", "release"], ["and", "js", "debug"]] // more complex conditions
      #|  }
      #|}
      #|```
      #|
      #|**Available conditions:**
      #|
      #|- **Backends**: `"wasm"`, `"wasm-gc"`, `"js"`, `"native"`
      #|- **Build modes**: `"debug"`, `"release"`
      #|- **Logical operators**: `"and"`, `"or"`, `"not"`
      #|
      #|## Link Configuration
      #|
      #|### Basic Linking
      #|
      #|```json
      #|{
      #|  "link": true, // Enable linking for this package
      #|  // OR for advanced cases:
      #|  "link": {
      #|    "wasm": {
      #|      "exports": ["hello", "foo:bar"], // Export functions
      #|      "heap-start-address": 1024, // Memory layout
      #|      "import-memory": {
      #|        // Import external memory
      #|        "module": "env",
      #|        "name": "memory"
      #|      },
      #|      "export-memory-name": "memory" // Export memory with name
      #|    },
      #|    "wasm-gc": {
      #|      "exports": ["hello"],
      #|      "use-js-builtin-string": true, // JS String Builtin support
      #|      "imported-string-constants": "_" // String namespace
      #|    },
      #|    "js": {
      #|      "exports": ["hello"],
      #|      "format": "esm" // "esm", "cjs", or "iife"
      #|    },
      #|    "native": {
      #|      "cc": "gcc", // C compiler
      #|      "cc-flags": "-O2 -DMOONBIT", // Compile flags
      #|      "cc-link-flags": "-s" // Link flags
      #|    }
      #|  }
      #|}
      #|```
      #|
      #|## Warning Control
      #|
      #|Disable specific warnings in `moon.mod.json` or `moon.pkg.json`:
      #|
      #|```json
      #|{
      #|  "warn-list": "-2-29" // Disable unused variable (2) & unused package (29)
      #|}
      #|```
      #|
      #|**Common warning numbers:**
      #|
      #|- `1` - Unused function
      #|- `2` - Unused variable
      #|- `11` - Partial pattern matching
      #|- `12` - Unreachable code
      #|- `29` - Unused package
      #|
      #|Use `moonc build-package -warn-help` to see all available warnings.
      #|
      #|## Pre-build Commands
      #|
      #|Embed external files as MoonBit code:
      #|
      #|```json
      #|{
      #|  "pre-build": [
      #|    {
      #|      "input": "data.txt",
      #|      "output": "embedded.mbt",
      #|      "command": ":embed -i $input -o $output --name data --text"
      #|    },
      #|    ... // more embed commands
      #|  ]
      #|}
      #|```
      #|
      #|Generated code example:
      #|
      #|```mbt check
      #|///|
      #|let data : String =
      #|  #|hello,
      #|  #|world
      #|  #|
      #|```
    ),
  },
  @assets.Asset::{
    path: "moonbit-agent-guide/references/moonbit-language-fundamentals.mbt.md",
    content: (
      #|# MoonBit Language Fundamentals
      #|
      #|
      #|## Quick reference:
      #|
      #|```mbt check
      #|///|
      #|/// comments doc string
      #|pub fn sum(x : Int, y : Int) -> Int {
      #|  x + y
      #|}
      #|
      #|///|
      #|struct Rect {
      #|  width : Int
      #|  height : Int
      #|}
      #|
      #|///|
      #|fn Rect::area(self : Rect) -> Int {
      #|  self.width * self.height
      #|}
      #|
      #|///|
      #|pub impl Show for Rect with output(_self, logger) {
      #|  logger.write_string("Rect")
      #|}
      #|
      #|///|
      #|enum MyOption {
      #|  MyNone
      #|  MySome(Int)
      #|} derive(Show, ToJson, Eq, Compare)
      #|
      #|///|
      #|///  match + loops are expressions
      #|test "everything is expression in MoonBit" {
      #|  // tuple
      #|  let (n, opt) = (1, MySome(2))
      #|  // if expressions return values
      #|  let msg : String = if n > 0 { "pos" } else { "non-pos" }
      #|  let res = match opt {
      #|    MySome(x) => {
      #|      inspect(x, content="2")
      #|      1
      #|    }
      #|    MyNone => 0
      #|  }
      #|  let status : Result[Int, String] = Ok(10)
      #|  // match expressions return values
      #|  let description = match status {
      #|    Ok(value) => "Success: \{value}"
      #|    Err(error) => "Error: \{error}"
      #|  }
      #|  let array = [1, 2, 3, 4, 5]
      #|  let mut i = 0 // mutable bindings (local only, globals are immutable)
      #|  let target = 3
      #|  // loops return values with 'break'
      #|  let found : Int? = while i < array.length() {
      #|    if array[i] == target {
      #|      break Some(i) // Exit with value
      #|    }
      #|    i = i + 1
      #|  } else { // Value when loop completes normally
      #|    None
      #|  }
      #|  assert_eq(found, Some(2)) // Found at index 2
      #|}
      #|
      #|///|
      #|/// global bindings
      #|pub let my_name : String = "MoonBit"
      #|
      #|///|
      #|pub const PI : Double = 3.14159 // constants use UPPER_SNAKE or PascalCase
      #|
      #|///|
      #|pub fn maximum(xs : Array[Int]) -> Int raise {
      #|  // Toplevel functions are *mutually recursive* by default
      #|  // `raise` annotation means the function would raise any Error
      #|  //  Only add `raise XXError` when you do need track the specific error type
      #|  match xs {
      #|    [] => fail("Empty array") // fail() is built-in for generic errors
      #|    [x] => x
      #|    // pattern match over array, the `.. rest` is a rest pattern
      #|    // it is of type `ArrayView[Int]` which is a slice
      #|    [x, .. rest] => {
      #|      let mut max_val = x // `mut` only allowed in local bindings
      #|      for y in rest {
      #|        if y > max_val {
      #|          max_val = y
      #|        }
      #|      }
      #|      max_val // return can be omitted if the last expression is the return value
      #|    }
      #|  }
      #|}
      #|
      #|///|
      #|/// pub(all) means it can be both read and created outside the package
      #|pub(all) struct Point {
      #|  x : Int
      #|  mut y : Int
      #|} derive(Show, ToJson)
      #|
      #|///|
      #|pub enum MyResult[T, E] {
      #|  MyOk(T) // semicolon `;` is optional when we have a newline
      #|  MyErr(E) // Enum variants must start uppercase
      #|} derive(Show, Eq, ToJson)
      #|// pub means it can only be pattern matched outside the package
      #|// but it can not be created outside the package, use `pub(all)` otherwise
      #|
      #|///|
      #|/// pub (open) means the trait can be implemented for outside packages
      #|pub(open) trait Comparable {
      #|  compare(Self, Self) -> Int // `Self` refers to the implementing type
      #|}
      #|
      #|///|
      #|test "inspect test" {
      #|  let result = sum(1, 2)
      #|  inspect(result, content="3")
      #|  // The `content` can be auto-corrected by running `moon test --update`
      #|  let point = Point::{ x: 10, y: 20 }
      #|  // For complex structures, use json_inspect for better readability:
      #|  json_inspect(point, content={ "x": 10, "y": 20 })
      #|}
      #|```
      #|
      #|
      #|## Complex Types
      #|
      #|```mbt check
      #|///|
      #|pub type UserId = Int // Int is aliased to UserId - like symlink
      #|
      #|///|
      #|///  Tuple-struct for callback
      #|pub struct Handler((String) -> Unit) // A newtype wrapper
      #|
      #|///|
      #|/// Tuple-struct syntax for single-field newtypes
      #|struct Meters(Int) // Tuple-struct syntax
      #|
      #|///|
      #|let distance : Meters = Meters(100)
      #|
      #|///|
      #|let raw : Int = distance.0 // Access first field with .0
      #|
      #|///|
      #|struct Addr {
      #|  host : String
      #|  port : Int
      #|} derive(Show, Eq, ToJson, FromJson)
      #|
      #|///|
      #|/// Structural types with literal syntax
      #|let config : Addr = Addr::{
      #|  // `Type::` can be omitted since the type is already known
      #|  host: "localhost",
      #|  port: 8080,
      #|}
      #|
      #|
      #|```
      #|
      #|## Common Derivable Traits
      #|
      #|Most types can automatically derive standard traits using the `derive(...)` syntax:
      #|
      #|- **`Show`** - Enables `to_string()` and string interpolation with `\{value}`
      #|- **`Eq`** - Enables `==` and `!=` equality operators
      #|- **`Compare`** - Enables `<`, `>`, `<=`, `>=` comparison operators
      #|- **`ToJson`** - Enables `json_inspect()` for readable test output
      #|- **`Hash`** - Enables use as Map keys
      #|
      #|```mbt check
      #|///|
      #|struct Coordinate {
      #|  x : Int
      #|  y : Int
      #|} derive(Show, Eq, ToJson)
      #|
      #|///|
      #|enum Status {
      #|  Active
      #|  Inactive
      #|} derive(Show, Eq, Compare)
      #|```
      #|
      #|**Best practice**: Always derive `Show` and `Eq` for data types. Add `ToJson` if you plan to test them with `json_inspect()`.
      #|
      #|## Reference Semantics by Default
      #|
      #|MoonBit passes most types by reference semantically (the optimizer may copy
      #|immutables):
      #|
      #|```mbt check
      #|///|
      #|///  Structs with 'mut' fields are always passed by reference
      #|struct Counter {
      #|  mut value : Int
      #|}
      #|
      #|///|
      #|fn increment(c : Counter) -> Unit {
      #|  c.value += 1 // Modifies the original
      #|}
      #|
      #|///|
      #|/// Arrays and Maps are mutable references
      #|fn modify_array(arr : Array[Int]) -> Unit {
      #|  arr[0] = 999 // Modifies original array
      #|}
      #|
      #|///|
      #|test "reference semantics" {
      #|  let counter : Ref[Int] = Ref::{ val: 0 }
      #|  counter.val += 1
      #|  assert_true(counter.val is 1)
      #|  let arr : Array[Int] = [1, 2, 3] // unlike Rust, no `mut` keyword needed
      #|  modify_array(arr)
      #|  assert_true(arr[0] is 999)
      #|  let mut x = 3 // `mut` neeed for re-assignment to the bindings
      #|  x += 2
      #|  assert_true(x is 5)
      #|}
      #|```
      #|
      #|## Pattern Matching
      #|
      #|```mbt check
      #|///|
      #|#warnings("-unused_value")
      #|test "pattern match over Array, struct and StringView" {
      #|  let arr : Array[Int] = [10, 20, 25, 30]
      #|  match arr {
      #|    [] => ... // empty array
      #|    [single] => ... // single element
      #|    [first, .. middle, rest] => {
      #|      let _ : ArrayView[Int] = middle // middle is ArrayView[Int]  
      #|      assert_true(first is 10 && middle is [20, 25] && rest is 30)
      #|    }
      #|  }
      #|  fn process_point(point : Point) -> Unit {
      #|    match point {
      #|      { x: 0, y: 0 } => ...
      #|      { x, y } if x == y => ...
      #|      { x, .. } if x < 0 => ...
      #|      ...
      #|    }
      #|  }
      #|  /// StringView pattern matching for parsing
      #|  fn is_palindrome(s : StringView) -> Bool {
      #|    loop s {
      #|      [] | [_] => true
      #|      [a, .. rest, b] if a == b => continue rest
      #|      // a is of type Char, rest is of type StringView
      #|      _ => false
      #|    }
      #|  }
      #|
      #|
      #|}
      #|```
      #|
      #|## Functional `loop` control flow
      #|
      #|The `loop` construct is unique to MoonBit:
      #|
      #|```mbt check
      #|///|
      #|/// Functional loop with pattern matching on loop variables
      #|/// @list.List is from the standard library
      #|fn sum_list(list : @list.List[Int]) -> Int {
      #|  loop (list, 0) {
      #|    (Empty, acc) => acc // Base case returns accumulator
      #|    (More(x, tail=rest), acc) => continue (rest, x + acc) // Recurse with new values
      #|  }
      #|}
      #|
      #|///|
      #|///  Multiple loop variables with complex control flow
      #|fn find_pair(arr : Array[Int], target : Int) -> (Int, Int)? {
      #|  loop (0, arr.length() - 1) {
      #|    (i, j) if i >= j => None
      #|    (i, j) => {
      #|      let sum = arr[i] + arr[j]
      #|      if sum == target {
      #|        Some((i, j)) // Found pair
      #|      } else if sum < target {
      #|        continue (i + 1, j) // Move left pointer
      #|      } else {
      #|        continue (i, j - 1) // Move right pointer
      #|      }
      #|    }
      #|  }
      #|}
      #|```
      #|
      #|**Note**: You must provide a payload to `loop`. If you want an infinite loop, use `while true { ... }` instead. The syntax `loop { ... }` without arguments is invalid.
      #|
      #|
      #|## Methods and Traits
      #|
      #|Methods use `Type::method_name` syntax, traits require explicit implementation:
      #|
      #|```mbt check
      #|///|
      #|struct Rectangle {
      #|  width : Double
      #|  height : Double
      #|}
      #|
      #|///|
      #|// Methods are prefixed with Type::
      #|fn Rectangle::area(self : Rectangle) -> Double {
      #|  self.width * self.height
      #|}
      #|
      #|///|
      #|/// Static methods don't need self
      #|fn Rectangle::new(w : Double, h : Double) -> Rectangle {
      #|  { width: w, height: h }
      #|}
      #|
      #|///|
      #|/// Show trait now uses output(self, logger) for custom formatting
      #|/// to_string() is automatically derived from this
      #|pub impl Show for Rectangle with output(self, logger) {
      #|  logger.write_string("Rectangle(\{self.width}x\{self.height})")
      #|}
      #|
      #|///|
      #|/// Traits can have non-object-safe methods
      #|trait Named {
      #|  name() -> String // No 'self' parameter - not object-safe
      #|}
      #|
      #|///|
      #|/// Trait bounds in generics
      #|fn[T : Show + Named] describe(value : T) -> String {
      #|  "\{T::name()}: \{value.to_string()}"
      #|}
      #|
      #|///|
      #|///  Trait implementation
      #|impl Hash for Rectangle with hash_combine(self, hasher) {
      #|  hasher..combine(self.width)..combine(self.height)
      #|}
      #|```
      #|
      #|## Operator Overloading
      #|
      #|MoonBit supports operator overloading through traits:
      #|
      #|```mbt check
      #|///|
      #|struct Vector(Int, Int)
      #|
      #|///|
      #|/// Implement arithmetic operators
      #|pub impl Add for Vector with add(self, other) {
      #|  Vector(self.0 + other.0, self.1 + other.1)
      #|}
      #|
      #|///|
      #|struct Person {
      #|  age : Int
      #|} derive(Eq)
      #|
      #|///|
      #|/// Comparison operators
      #|pub impl Compare for Person with compare(self, other) {
      #|  self.age.compare(other.age)
      #|}
      #|
      #|///|
      #|test "overloading" {
      #|  let v1 : Vector = Vector(1, 2)
      #|  let v2 : Vector = Vector(3, 4)
      #|  let _v3 : Vector = v1 + v2
      #|
      #|}
      #|```
      #|
      #|## Access Control Modifiers
      #|
      #|MoonBit has fine-grained visibility control:
      #|
      #|```mbt check
      #|///|
      #|/// `fn` defaults to Private - only visible in current package
      #|fn internal_helper() -> Unit {
      #|  ...
      #|}
      #|
      #|///|
      #|pub fn get_value() -> Int {
      #|  ...
      #|}
      #|
      #|///|
      #|// Struct (default) - type visible, implementation hidden
      #|struct DataStructure {}
      #|
      #|///|
      #|/// `pub struct` defaults to readonly - can read, pattern match, but not create
      #|pub struct Config {}
      #|
      #|///|
      #|///  Public all - full access
      #|pub(all) struct Config2 {}
      #|
      #|///|
      #|/// Abstract trait (default) - cannot be implemented by
      #|/// types outside this package
      #|pub trait MyTrait {}
      #|
      #|///|
      #|///  Open for extension
      #|pub(open) trait Extendable {}
      #|```
    ),
  },
  @assets.Asset::{
    path: "moonbit-agent-guide/references/moonbit-language-fundamentals.md",
    content: (
      #|# MoonBit Language Fundamentals
      #|
      #|
      #|## Quick reference:
      #|
      #|```mbt check
      #|///|
      #|/// comments doc string
      #|pub fn sum(x : Int, y : Int) -> Int {
      #|  x + y
      #|}
      #|
      #|///|
      #|struct Rect {
      #|  width : Int
      #|  height : Int
      #|}
      #|
      #|///|
      #|fn Rect::area(self : Rect) -> Int {
      #|  self.width * self.height
      #|}
      #|
      #|///|
      #|pub impl Show for Rect with output(_self, logger) {
      #|  logger.write_string("Rect")
      #|}
      #|
      #|///|
      #|enum MyOption {
      #|  MyNone
      #|  MySome(Int)
      #|} derive(Show, ToJson, Eq, Compare)
      #|
      #|///|
      #|///  match + loops are expressions
      #|test "everything is expression in MoonBit" {
      #|  // tuple
      #|  let (n, opt) = (1, MySome(2))
      #|  // if expressions return values
      #|  let msg : String = if n > 0 { "pos" } else { "non-pos" }
      #|  let res = match opt {
      #|    MySome(x) => {
      #|      inspect(x, content="2")
      #|      1
      #|    }
      #|    MyNone => 0
      #|  }
      #|  let status : Result[Int, String] = Ok(10)
      #|  // match expressions return values
      #|  let description = match status {
      #|    Ok(value) => "Success: \{value}"
      #|    Err(error) => "Error: \{error}"
      #|  }
      #|  let array = [1, 2, 3, 4, 5]
      #|  let mut i = 0 // mutable bindings (local only, globals are immutable)
      #|  let target = 3
      #|  // loops return values with 'break'
      #|  let found : Int? = while i < array.length() {
      #|    if array[i] == target {
      #|      break Some(i) // Exit with value
      #|    }
      #|    i = i + 1
      #|  } else { // Value when loop completes normally
      #|    None
      #|  }
      #|  assert_eq(found, Some(2)) // Found at index 2
      #|}
      #|
      #|///|
      #|/// global bindings
      #|pub let my_name : String = "MoonBit"
      #|
      #|///|
      #|pub const PI : Double = 3.14159 // constants use UPPER_SNAKE or PascalCase
      #|
      #|///|
      #|pub fn maximum(xs : Array[Int]) -> Int raise {
      #|  // Toplevel functions are *mutually recursive* by default
      #|  // `raise` annotation means the function would raise any Error
      #|  //  Only add `raise XXError` when you do need track the specific error type
      #|  match xs {
      #|    [] => fail("Empty array") // fail() is built-in for generic errors
      #|    [x] => x
      #|    // pattern match over array, the `.. rest` is a rest pattern
      #|    // it is of type `ArrayView[Int]` which is a slice
      #|    [x, .. rest] => {
      #|      let mut max_val = x // `mut` only allowed in local bindings
      #|      for y in rest {
      #|        if y > max_val {
      #|          max_val = y
      #|        }
      #|      }
      #|      max_val // return can be omitted if the last expression is the return value
      #|    }
      #|  }
      #|}
      #|
      #|///|
      #|/// pub(all) means it can be both read and created outside the package
      #|pub(all) struct Point {
      #|  x : Int
      #|  mut y : Int
      #|} derive(Show, ToJson)
      #|
      #|///|
      #|pub enum MyResult[T, E] {
      #|  MyOk(T) // semicolon `;` is optional when we have a newline
      #|  MyErr(E) // Enum variants must start uppercase
      #|} derive(Show, Eq, ToJson)
      #|// pub means it can only be pattern matched outside the package
      #|// but it can not be created outside the package, use `pub(all)` otherwise
      #|
      #|///|
      #|/// pub (open) means the trait can be implemented for outside packages
      #|pub(open) trait Comparable {
      #|  compare(Self, Self) -> Int // `Self` refers to the implementing type
      #|}
      #|
      #|///|
      #|test "inspect test" {
      #|  let result = sum(1, 2)
      #|  inspect(result, content="3")
      #|  // The `content` can be auto-corrected by running `moon test --update`
      #|  let point = Point::{ x: 10, y: 20 }
      #|  // For complex structures, use json_inspect for better readability:
      #|  json_inspect(point, content={ "x": 10, "y": 20 })
      #|}
      #|```
      #|
      #|
      #|## Complex Types
      #|
      #|```mbt check
      #|///|
      #|pub type UserId = Int // Int is aliased to UserId - like symlink
      #|
      #|///|
      #|///  Tuple-struct for callback
      #|pub struct Handler((String) -> Unit) // A newtype wrapper
      #|
      #|///|
      #|/// Tuple-struct syntax for single-field newtypes
      #|struct Meters(Int) // Tuple-struct syntax
      #|
      #|///|
      #|let distance : Meters = Meters(100)
      #|
      #|///|
      #|let raw : Int = distance.0 // Access first field with .0
      #|
      #|///|
      #|struct Addr {
      #|  host : String
      #|  port : Int
      #|} derive(Show, Eq, ToJson, FromJson)
      #|
      #|///|
      #|/// Structural types with literal syntax
      #|let config : Addr = Addr::{
      #|  // `Type::` can be omitted since the type is already known
      #|  host: "localhost",
      #|  port: 8080,
      #|}
      #|
      #|
      #|```
      #|
      #|## Common Derivable Traits
      #|
      #|Most types can automatically derive standard traits using the `derive(...)` syntax:
      #|
      #|- **`Show`** - Enables `to_string()` and string interpolation with `\{value}`
      #|- **`Eq`** - Enables `==` and `!=` equality operators
      #|- **`Compare`** - Enables `<`, `>`, `<=`, `>=` comparison operators
      #|- **`ToJson`** - Enables `json_inspect()` for readable test output
      #|- **`Hash`** - Enables use as Map keys
      #|
      #|```mbt check
      #|///|
      #|struct Coordinate {
      #|  x : Int
      #|  y : Int
      #|} derive(Show, Eq, ToJson)
      #|
      #|///|
      #|enum Status {
      #|  Active
      #|  Inactive
      #|} derive(Show, Eq, Compare)
      #|```
      #|
      #|**Best practice**: Always derive `Show` and `Eq` for data types. Add `ToJson` if you plan to test them with `json_inspect()`.
      #|
      #|## Reference Semantics by Default
      #|
      #|MoonBit passes most types by reference semantically (the optimizer may copy
      #|immutables):
      #|
      #|```mbt check
      #|///|
      #|///  Structs with 'mut' fields are always passed by reference
      #|struct Counter {
      #|  mut value : Int
      #|}
      #|
      #|///|
      #|fn increment(c : Counter) -> Unit {
      #|  c.value += 1 // Modifies the original
      #|}
      #|
      #|///|
      #|/// Arrays and Maps are mutable references
      #|fn modify_array(arr : Array[Int]) -> Unit {
      #|  arr[0] = 999 // Modifies original array
      #|}
      #|
      #|///|
      #|test "reference semantics" {
      #|  let counter : Ref[Int] = Ref::{ val: 0 }
      #|  counter.val += 1
      #|  assert_true(counter.val is 1)
      #|  let arr : Array[Int] = [1, 2, 3] // unlike Rust, no `mut` keyword needed
      #|  modify_array(arr)
      #|  assert_true(arr[0] is 999)
      #|  let mut x = 3 // `mut` neeed for re-assignment to the bindings
      #|  x += 2
      #|  assert_true(x is 5)
      #|}
      #|```
      #|
      #|## Pattern Matching
      #|
      #|```mbt check
      #|///|
      #|#warnings("-unused_value")
      #|test "pattern match over Array, struct and StringView" {
      #|  let arr : Array[Int] = [10, 20, 25, 30]
      #|  match arr {
      #|    [] => ... // empty array
      #|    [single] => ... // single element
      #|    [first, .. middle, rest] => {
      #|      let _ : ArrayView[Int] = middle // middle is ArrayView[Int]  
      #|      assert_true(first is 10 && middle is [20, 25] && rest is 30)
      #|    }
      #|  }
      #|  fn process_point(point : Point) -> Unit {
      #|    match point {
      #|      { x: 0, y: 0 } => ...
      #|      { x, y } if x == y => ...
      #|      { x, .. } if x < 0 => ...
      #|      ...
      #|    }
      #|  }
      #|  /// StringView pattern matching for parsing
      #|  fn is_palindrome(s : StringView) -> Bool {
      #|    loop s {
      #|      [] | [_] => true
      #|      [a, .. rest, b] if a == b => continue rest
      #|      // a is of type Char, rest is of type StringView
      #|      _ => false
      #|    }
      #|  }
      #|
      #|
      #|}
      #|```
      #|
      #|## Functional `loop` control flow
      #|
      #|The `loop` construct is unique to MoonBit:
      #|
      #|```mbt check
      #|///|
      #|/// Functional loop with pattern matching on loop variables
      #|/// @list.List is from the standard library
      #|fn sum_list(list : @list.List[Int]) -> Int {
      #|  loop (list, 0) {
      #|    (Empty, acc) => acc // Base case returns accumulator
      #|    (More(x, tail=rest), acc) => continue (rest, x + acc) // Recurse with new values
      #|  }
      #|}
      #|
      #|///|
      #|///  Multiple loop variables with complex control flow
      #|fn find_pair(arr : Array[Int], target : Int) -> (Int, Int)? {
      #|  loop (0, arr.length() - 1) {
      #|    (i, j) if i >= j => None
      #|    (i, j) => {
      #|      let sum = arr[i] + arr[j]
      #|      if sum == target {
      #|        Some((i, j)) // Found pair
      #|      } else if sum < target {
      #|        continue (i + 1, j) // Move left pointer
      #|      } else {
      #|        continue (i, j - 1) // Move right pointer
      #|      }
      #|    }
      #|  }
      #|}
      #|```
      #|
      #|**Note**: You must provide a payload to `loop`. If you want an infinite loop, use `while true { ... }` instead. The syntax `loop { ... }` without arguments is invalid.
      #|
      #|
      #|## Methods and Traits
      #|
      #|Methods use `Type::method_name` syntax, traits require explicit implementation:
      #|
      #|```mbt check
      #|///|
      #|struct Rectangle {
      #|  width : Double
      #|  height : Double
      #|}
      #|
      #|///|
      #|// Methods are prefixed with Type::
      #|fn Rectangle::area(self : Rectangle) -> Double {
      #|  self.width * self.height
      #|}
      #|
      #|///|
      #|/// Static methods don't need self
      #|fn Rectangle::new(w : Double, h : Double) -> Rectangle {
      #|  { width: w, height: h }
      #|}
      #|
      #|///|
      #|/// Show trait now uses output(self, logger) for custom formatting
      #|/// to_string() is automatically derived from this
      #|pub impl Show for Rectangle with output(self, logger) {
      #|  logger.write_string("Rectangle(\{self.width}x\{self.height})")
      #|}
      #|
      #|///|
      #|/// Traits can have non-object-safe methods
      #|trait Named {
      #|  name() -> String // No 'self' parameter - not object-safe
      #|}
      #|
      #|///|
      #|/// Trait bounds in generics
      #|fn[T : Show + Named] describe(value : T) -> String {
      #|  "\{T::name()}: \{value.to_string()}"
      #|}
      #|
      #|///|
      #|///  Trait implementation
      #|impl Hash for Rectangle with hash_combine(self, hasher) {
      #|  hasher..combine(self.width)..combine(self.height)
      #|}
      #|```
      #|
      #|## Operator Overloading
      #|
      #|MoonBit supports operator overloading through traits:
      #|
      #|```mbt check
      #|///|
      #|struct Vector(Int, Int)
      #|
      #|///|
      #|/// Implement arithmetic operators
      #|pub impl Add for Vector with add(self, other) {
      #|  Vector(self.0 + other.0, self.1 + other.1)
      #|}
      #|
      #|///|
      #|struct Person {
      #|  age : Int
      #|} derive(Eq)
      #|
      #|///|
      #|/// Comparison operators
      #|pub impl Compare for Person with compare(self, other) {
      #|  self.age.compare(other.age)
      #|}
      #|
      #|///|
      #|test "overloading" {
      #|  let v1 : Vector = Vector(1, 2)
      #|  let v2 : Vector = Vector(3, 4)
      #|  let _v3 : Vector = v1 + v2
      #|
      #|}
      #|```
      #|
      #|## Access Control Modifiers
      #|
      #|MoonBit has fine-grained visibility control:
      #|
      #|```mbt check
      #|///|
      #|/// `fn` defaults to Private - only visible in current package
      #|fn internal_helper() -> Unit {
      #|  ...
      #|}
      #|
      #|///|
      #|pub fn get_value() -> Int {
      #|  ...
      #|}
      #|
      #|///|
      #|// Struct (default) - type visible, implementation hidden
      #|struct DataStructure {}
      #|
      #|///|
      #|/// `pub struct` defaults to readonly - can read, pattern match, but not create
      #|pub struct Config {}
      #|
      #|///|
      #|///  Public all - full access
      #|pub(all) struct Config2 {}
      #|
      #|///|
      #|/// Abstract trait (default) - cannot be implemented by
      #|/// types outside this package
      #|pub trait MyTrait {}
      #|
      #|///|
      #|///  Open for extension
      #|pub(open) trait Extendable {}
      #|```
    ),
  },
]

///|
let system_assets_fingerprint : String = "6694c37e13f8c50f8779b2a648cd65e3bd3a8691daa2a8ad2ea891cb6031d059"
