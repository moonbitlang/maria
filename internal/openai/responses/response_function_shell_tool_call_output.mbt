///|
/// The output of a shell tool call.
struct ResponseFunctionShellToolCallOutput {
  /// The unique ID of the shell call output. Populated when this item is returned via API.
  id : String
  /// The unique ID of the shell tool call generated by the model.
  call_id : String
  /// The maximum length of the shell command output. Generated by the model and should accompany the raw output.
  max_output_length : Int64
  /// An array of shell call output contents.
  output : Array[ResponseFunctionShellToolCallOutputOutput]
  /// The ID of the entity that created this tool call output.
  created_by : String?
}

///|
/// The content of a shell call output.
struct ResponseFunctionShellToolCallOutputOutput {
  /// Represents either an exit or timeout outcome for this output chunk.
  outcome : ResponseFunctionShellToolCallOutputOutcome
  /// Captured stderr for the shell call output chunk.
  stderr : String
  /// Captured stdout for the shell call output chunk.
  stdout : String
  /// The ID of the entity that emitted this chunk.
  created_by : String?
}

///|
enum ResponseFunctionShellToolCallOutputOutcome {
  Timeout(ResponseFunctionShellToolCallOutputOutcomeTimeout)
  Exit(ResponseFunctionShellToolCallOutputOutcomeExit)
}

///|
/// Indicates that the shell call exceeded its configured time limit.
struct ResponseFunctionShellToolCallOutputOutcomeTimeout {}

///|
/// Indicates that the shell commands finished and returned an exit code.
struct ResponseFunctionShellToolCallOutputOutcomeExit {
  /// Exit code from the shell process.
  exit_code : Int64
}

///|
pub impl ToJson for ResponseFunctionShellToolCallOutputOutcome with to_json(
  self : ResponseFunctionShellToolCallOutputOutcome,
) -> Json {
  match self {
    Timeout(outcome) => outcome.to_json()
    Exit(outcome) => outcome.to_json()
  }
}

///|
pub impl @json.FromJson for ResponseFunctionShellToolCallOutputOutcome with from_json(
  json : Json,
  path : @json.JsonPath,
) -> ResponseFunctionShellToolCallOutputOutcome raise @json.JsonDecodeError {
  let object = @jsonx.as_object(json, path~)
  let type_str : String = object.required("type", path~)
  match type_str {
    "timeout" => {
      let outcome = @json.from_json(json, path~)
      Timeout(outcome)
    }
    "exit" => {
      let outcome = @json.from_json(json, path~)
      Exit(outcome)
    }
    _ =>
      raise @json.JsonDecodeError(
        (
          path.add_key("type"),
          "ResponseFunctionShellToolCallOutputOutcome: invalid type '\{type_str}'",
        ),
      )
  }
}

///|
pub impl ToJson for ResponseFunctionShellToolCallOutputOutcomeTimeout with to_json(
  _ : ResponseFunctionShellToolCallOutputOutcomeTimeout,
) -> Json {
  { "type": "timeout" }
}

///|
pub impl @json.FromJson for ResponseFunctionShellToolCallOutputOutcomeTimeout with from_json(
  json : Json,
  path : @json.JsonPath,
) -> ResponseFunctionShellToolCallOutputOutcomeTimeout raise @json.JsonDecodeError {
  let object = @jsonx.as_object(json, path~)
  let _ : String = object.required("type", path~)
  ResponseFunctionShellToolCallOutputOutcomeTimeout::{  }
}

///|
pub impl ToJson for ResponseFunctionShellToolCallOutputOutcomeExit with to_json(
  self : ResponseFunctionShellToolCallOutputOutcomeExit,
) -> Json {
  { "type": "exit", "exit_code": @jsonx.int64(self.exit_code) }
}

///|
pub impl @json.FromJson for ResponseFunctionShellToolCallOutputOutcomeExit with from_json(
  json : Json,
  path : @json.JsonPath,
) -> ResponseFunctionShellToolCallOutputOutcomeExit raise @json.JsonDecodeError {
  let object = @jsonx.as_object(json, path~)
  let _ : String = object.required("type", path~)
  let exit_code = object.required_int64("exit_code", path~)
  ResponseFunctionShellToolCallOutputOutcomeExit::{ exit_code, }
}

///|
pub impl ToJson for ResponseFunctionShellToolCallOutputOutput with to_json(
  self : ResponseFunctionShellToolCallOutputOutput,
) -> Json {
  let obj : Map[String, Json] = {
    "outcome": self.outcome,
    "stderr": self.stderr,
    "stdout": self.stdout,
  }
  if self.created_by is Some(created_by) {
    obj["created_by"] = created_by.to_json()
  }
  Json::object(obj)
}

///|
pub impl @json.FromJson for ResponseFunctionShellToolCallOutputOutput with from_json(
  json : Json,
  path : @json.JsonPath,
) -> ResponseFunctionShellToolCallOutputOutput raise @json.JsonDecodeError {
  let object = @jsonx.as_object(json, path~)
  let outcome : ResponseFunctionShellToolCallOutputOutcome = object.required(
    "outcome",
    path~,
  )
  let stderr : String = object.required("stderr", path~)
  let stdout : String = object.required("stdout", path~)
  let created_by : String? = object.optional("created_by", path~)
  ResponseFunctionShellToolCallOutputOutput::{
    outcome,
    stderr,
    stdout,
    created_by,
  }
}

///|
pub impl ToJson for ResponseFunctionShellToolCallOutput with to_json(
  self : ResponseFunctionShellToolCallOutput,
) -> Json {
  let obj : Map[String, Json] = {
    "type": "shell_call_output",
    "id": self.id,
    "call_id": self.call_id,
    "max_output_length": @jsonx.int64(self.max_output_length),
    "output": self.output,
  }
  if self.created_by is Some(created_by) {
    obj["created_by"] = created_by.to_json()
  }
  Json::object(obj)
}

///|
pub impl @json.FromJson for ResponseFunctionShellToolCallOutput with from_json(
  json : Json,
  path : @json.JsonPath,
) -> ResponseFunctionShellToolCallOutput raise @json.JsonDecodeError {
  let object = @jsonx.as_object(json, path~)
  let id : String = object.required("id", path~)
  let call_id : String = object.required("call_id", path~)
  let max_output_length = object.required_int64("max_output_length", path~)
  let output : Array[ResponseFunctionShellToolCallOutputOutput] = object.required(
    "output",
    path~,
  )
  let _ : String = object.required("type", path~)
  let created_by : String? = object.optional("created_by", path~)
  ResponseFunctionShellToolCallOutput::{
    id,
    call_id,
    max_output_length,
    output,
    created_by,
  }
}
