///|
struct Loader {
  logger : @pino.Logger
  cwd : String
  rules : Map[String, Rule]
}

///|
pub fn Loader::new(cwd : String, logger~ : @pino.Logger) -> Loader {
  return Loader::{ cwd, logger, rules: {} }
}

///|
async fn Loader::load_rules_from_directory(
  self : Loader,
  directory : String,
  source~ : Source,
) -> Unit {
  if !@fs.exists(directory) {
    self.logger.warn("Directory '\{directory}' does not exist, skipping.", {})
    return
  }
  let dir = @fs.list_directory(directory).filter(e => e.kind
    is @fs.FileKind::Regular &&
    e.name.has_suffix(".md"))
  for rule_path in dir {
    let relative_path = "./" + rule_path.name
    let path = @path.Path::parse(relative_path)
    let file = path.file().unwrap()
    self.rules[file.base] = Rule::parse(@fs.read_file(rule_path.path), source~)
  }
}

///|
pub async fn Loader::load(self : Loader) -> Unit {
  let home_path = @path.Path::parse(@os.home() + "/")
  let path_builder = @path.PathBuilder::from_path(home_path)
  path_builder..add_directory(".moonagent")..add_directory("rules")
  let global_path = path_builder.to_string()
  self.load_rules_from_directory(global_path, source=Global)
  let cwd_path = @path.Path::parse(self.cwd + "/")
  let path_builder = @path.PathBuilder::from_path(cwd_path)
  path_builder..add_directory(".moonagent")..add_directory("rules")
  let local_path = path_builder.to_string()
  self.load_rules_from_directory(local_path, source=Local)
}

///|
pub enum Source {
  Global
  Local
} derive(Show, ToJson)

///|
pub struct Rule {
  description : String?
  globs : Array[String]
  always_apply : Bool
  content : String
  source : Source
} derive(Show, ToJson)

///|
fn Rule::parse(content : String, source~ : Source) -> Rule {
  let doc = @yamd.parse(content)
  let description = match doc.meta.get("description") {
    Some(Json::String(desc)) => Some(desc)
    _ => None
  }
  let globs = match doc.meta.get("globs") {
    Some(Json::Array(arr)) =>
      arr
      .iter()
      .filter_map(v => match v {
        Json::String(s) => Some(s)
        _ => None
      })
      .collect()
    _ => []
  }
  let always_apply : Bool = match doc.meta.get("alwaysApply") {
    Some(True) => true
    Some(False) => false
    _ => false
  }
  Rule::{ description, globs, always_apply, content: doc.text, source }
}

///|
test "Rule::parse" {
  let content =
    #|---
    #|description: "This is a test rule"
    #|globs: ["**/*.js", "**/*.ts"]
    #|alwaysApply: true
    #|---
    #|
    #|console.log("Hello, world!");
    #|
  let rule = Rule::parse(content.to_string(), source=Global)
  @json.inspect(rule, content={
    "description": "This is a test rule",
    "globs": ["**/*.js", "**/*.ts"],
    "always_apply": true,
    "content": "\nconsole.log(\"Hello, world!\");",
    "source": "Global",
  })
}

///|
pub fn Loader::format(self : Loader) -> String {
  let always_applied = []
  let conditional = []
  for name, rule in self.rules {
    if rule.always_apply {
      always_applied.push((name, rule))
    } else {
      conditional.push((name, rule))
    }
  }
  let content = StringBuilder::new()
  content.write_string(
    (
      $|# Project Rules
      $|
      $|Loaded \{self.rules.length()} rules from .moonagent/rules directory:
      $|
    ),
  )
  for rule in always_applied {
    let (name, rule) = rule
    let description = match rule.description {
      Some(desc) => desc
      None => "No description"
    }
    content.write_string(
      (
        $|
        $|## \{name}
        $|
        $|\{description}
        $|
        $|- **Always Apply**: \{rule.always_apply}
        $|
      ),
    )
    if rule.globs.length() > 0 {
      let globs = rule.globs.join(", ")
      content.write_string(
        (
          $|- **Globs**: [\{globs}]
          $|
        ),
      )
    }
    content.write_string(
      (
        $|- **Description**: \{description}
        $|
        $|\{rule.content}
        $|
      ),
    )
  }
  for rule in conditional {
    let (name, rule) = rule
    let description = match rule.description {
      Some(desc) => desc
      None => "No description"
    }
    content.write_string(
      (
        $|
        $|## \{name}
        $|
        $|\{description}
        $|
        $|- **Always Apply**: \{rule.always_apply}
        $|
      ),
    )
    if rule.globs.length() > 0 {
      let globs = rule.globs.join(", ")
      content.write_string(
        (
          $|- **Globs**: [\{globs}]
          $|
        ),
      )
    }
    content.write_string(
      (
        $|- **Description**: \{description}
        $|
      ),
    )
  }
  content.to_string()
}
