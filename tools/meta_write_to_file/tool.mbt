///|
/// Enhanced file writing tool that automatically formats MoonBit files and fixes syntax errors
/// This is a MoonBit translation of the TypeScript meta_write_to_file tool

///|
/// Check if a file is a MoonBit file based on extension
fn is_moonbit_file(file_path : String) -> Bool {
  file_path.has_suffix(".mbt")
}

///|
/// Format a MoonBit file using moon fmt
async fn format_moonbit_source(source : String) -> String noraise {
  @moon.format_string(source) catch {
    _ => source // Return original source if formatting fails
  }
}

///|
async test {
  let input =
    #| enum X {
    #|  A,
    #|  B,
    #|  C
    #|}
    #|
    #|struct Hi {
    #|  x : Int,
    #|  y : String,
    #|}
    #|
  let output = format_moonbit_source(input)
  inspect(
    output,
    content=(
      #|///|
      #|enum X {
      #|  A
      #|  B
      #|  C
      #|}
      #|
      #|///|
      #|struct Hi {
      #|  x : Int
      #|  y : String
      #|}
      #|
    ),
  )

  // code generated by AI have syntax errors but no blockline
  let replace =
    #|enum Color {
    #|  Red,
    #|  Green,
    #|  Blue,
    #|}
    #|
    #|fn Color::to_string(self : Color) -> String {
    #|  switch self {
    #|    Red => "red",
    #|    Green => "green",
    #|    Blue => "blue",
    #|  }
    #|}
    #|
    #|fn main() {
    #|
    #|  let color : Color = Blue
    #|  println(color.to_string())
    #|}
    #|
  inspect(
    format_moonbit_source(replace),
    content=(
      #|enum Color {
      #|  Red,
      #|  Green,
      #|  Blue,
      #|}
      #|
      #|fn Color::to_string(self : Color) -> String {
      #|  switch self {
      #|    Red => "red",
      #|    Green => "green",
      #|    Blue => "blue",
      #|  }
      #|}
      #|
      #|fn main() {
      #|
      #|  let color : Color = Blue
      #|  println(color.to_string())
      #|}
      #|
    ),
  )
  let replace2 =
    #|///| 
    #|enum Color {
    #|  Red,
    #|  Green,
    #|  Blue,
    #|}
    #|///|
    #|fn Color::to_string(self : Color) -> String {
    #|  switch self {
    #|    Red => "red",
    #|    Green => "green",
    #|    Blue => "blue",
    #|  }
    #|}
    #|
    #|fn main() {
    #|
    #|  let color : Color = Blue
    #|  println(color.to_string())
    #|}
    #|
  // this works due to blockline
  inspect(
    format_moonbit_source(replace2),
    content=(
      #|///|
      #|enum Color {
      #|  Red
      #|  Green
      #|  Blue
      #|}
      #|
      #|///|
      #|fn Color::to_string(self : Color) -> String {
      #|  switch self {
      #|    Red => "red",
      #|    Green => "green",
      #|    Blue => "blue",
      #|  }
      #|}
      #|
      #|fn main() {
      #|
      #|  let color : Color = Blue
      #|  println(color.to_string())
      #|}
      #|
    ),
  )
}

///|
const DiagnosticLimit : Int = 10

///|
fn attempt_completion_new(ctx : FixingContext) -> @tool.Tool[String] {
  @tool.new(
    name="attempt_completion",
    description="Signal that syntax fixing is complete",
    schema=completion_schema,
    async fn(args) -> @tool.ToolResult[String] noraise {
      let { result } : InputCompletion = @json.from_json(args) catch {
        err =>
          return @tool.error(
            "Invalid arguments provided to attempt_completion: \{err}",
          )
      }
      ctx.result = Some(result)
      @tool.ok("Syntax fixing completed successfully.")
    },
  )
}

///|
async fn execute_replace_in_file(
  params : MetaWriteParams,
  resolved_path : String,
) -> @tool.ToolResult[String] noraise {
  let replace = params.replace
  match params.search {
    None | Some("") =>
      try {
        mkdir_then_write(resolved_path, replace)
        @tool.ok("File written successfully to \{params.path}")
      } catch {
        error => @tool.error("Error writing to file: \{error}", error~)
      }
    Some(search) =>
      try {
        let content = @fsx.read_file(resolved_path)
        match @fuzzy.find_match(content, search) {
          None =>
            @tool.error(
              (
                $|Search content not found in file:
                $|
                $|**Search**:
                $|
                $|```
                $|\{search}
                $|```
                $|
                $|**File Content**:
                $|
                $|```
                $|\{content}
                $|```
              ),
            )
          Some(match_result) => {
            let before = content[0:match_result.position].to_string()
            let after = content[match_result.position + match_result.length:].to_string()
            let new_content = before + replace + after
            @fsx.write_to_file(resolved_path, new_content)
            @tool.ok("Changes applied to \{params.path}")
          }
        }
      } catch {
        error => @tool.error("Error writing to file: \{error}", error~)
      }
  }
}

///|
async fn mkdir_then_write(path : String, content : String) -> Unit {
  @fsx.make_directory(@pathx.dirname(path), recursive=true, exists_ok=true)
  @fsx.write_to_file(path, content)
}

///|
/// Execute the meta_write_to_file operation
async fn execute_meta_write_to_file(
  args : Json,
  agent : @agent.Agent,
) -> @tool.ToolResult[MetaWriteToFileResult] noraise {
  let params : MetaWriteParams = @json.from_json(args) catch {
    error =>
      return @tool.error(
        "Error: Invalid arguments provided to meta_write_to_file tool: \{error}",
        error~,
      )
  }
  let cwd = agent.cwd
  let resolved_path = if @pathx.is_absolute(params.path) {
    params.path
  } else {
    @pathx.join(cwd, params.path)
  }
  try {
    // If it's a MoonBit file, format it and fix syntax if needed
    if is_moonbit_file(resolved_path) {
      let file_exists = @fsx.exists(resolved_path)
      // Calculate initial content by applying search/replace
      let replace = params.replace
      let initial_content = match params.search {
        None | Some("") => replace
        Some(search) => {
          if !file_exists {
            return @tool.error(
              (
                $|File does not exist at path \{params.path}
                $|
                $|You cannot perform a search-and-replace operation on a
                $|non-existent file with a non-empty search string.
              ),
            )
          }
          let file_content = @fsx.read_file(resolved_path)
          match @fuzzy.find_match(file_content, search) {
            None =>
              return @tool.error(
                (
                  $|Search content not found in file:
                  $|
                  $|**Search**:
                  $|
                  $|```
                  $|\{search}
                  $|```
                  $|
                  $|**File Content**:
                  $|
                  $|```
                  $|\{file_content}
                  $|```
                ),
              )
            Some(match_result) => {
              let before = file_content[:match_result.position]
              let after = file_content[match_result.position +
                match_result.length:]
              "\{before}\{replace}\{after}"
            }
          }
        }
      }

      // Format the source, even if there are syntax errors, as some syntax
      // errors can be auto-corrected by the formatter.
      let formatted_content = format_moonbit_source(initial_content)

      // Check for syntax errors (but skip fixing for .mbt.md files)
      let diagnostics = @moon.check_syntax_of_string(
        // Use params.path for better readability in diagnostics
        path=params.path,
        formatted_content,
      )

      // If there is no syntax error, write the file and return
      if diagnostics.is_empty() {
        mkdir_then_write(resolved_path, formatted_content)
        let diff = generate_diff(initial_content, formatted_content)
        return @tool.ok({
          path: resolved_path,
          message: if params.search is Some(search) && search != "" {
            "Changes applied and formatted successfully to \{params.path}"
          } else {
            "File written and formatted successfully to \{params.path}"
          },
          diff,
          learning_prompt: None,
        })
      }

      // If there are syntax errors, fix them using sub-agent
      let syntax_errors = diagnostics.render(
        context=1,
        limit=DiagnosticLimit,
        overlay=Map::from_array([
          (@pathx.basename(params.path).to_string(), formatted_content),
        ]),
      )
      let fixing_ctx = FixingContext::{
        path: params.path,
        cwd,
        result: None,
        content: formatted_content,
        description: params.description,
        syntax_errors,
        parent_agent: agent,
      }
      fix_syntax_errors(fixing_ctx) catch {
        error =>
          return @tool.error(
            (
              $|Failed to fix syntax errors in 5 minutes: \{error}
              $|
              $|\{syntax_errors}
            ),
            error~,
          )
      }

      // Re-format the file after fixing syntax errors
      let final_content = format_moonbit_source(fixing_ctx.content)

      // Write final content to file
      mkdir_then_write(resolved_path, final_content)

      // Compare final content with initial content and generate diff
      let diff = generate_diff(initial_content, final_content)

      // Add syntax error learning prompt if there were syntax errors that got fixed
      let learning_prompt = if syntax_errors != "" && diff is Some(_) {
        let prompt =
          $|**⚠️ Syntax Error Learning Note:**
          $|
          $|The sub-agent has automatically fixed syntax errors in this MoonBit file.
          $|Please review the changes to understand what syntax issues were corrected.
          $|Pay attention to these patterns to avoid similar syntax errors in future MoonBit code:
          $|
          $|Original syntax errors that were fixed:
          $|
          $|\{syntax_errors}
          $|
          $|Summary of fixes applied:
          $|
          $|\{fixing_ctx.result.unwrap_or_default()}
        Some(prompt)
      } else {
        None
      }
      @tool.ok({
        path: resolved_path,
        message: if params.search is Some(_) {
          "Changes applied and formatted successfully to \{params.path}"
        } else {
          "File written and formatted successfully to \{params.path}"
        },
        diff,
        learning_prompt,
      })
    } else {
      // Non-MoonBit files: call replace_in_file directly
      let write_result : @tool.ToolResult[String] = execute_replace_in_file(
        params, resolved_path,
      )

      // Return early if write failed
      let write_result = match write_result {
        Error(error, message) => return @tool.error(message, error~)
        Ok(write_result) => write_result
      }
      @tool.ok({
        path: resolved_path,
        message: write_result,
        diff: None,
        learning_prompt: None,
      })
    }
  } catch {
    @os_error.OSError(_, ..) as error if error.is_EACCES() =>
      @tool.error(
        "Permission denied: Cannot write to file \{params.path}. The file does not have write permissions.",
      )
    error => @tool.error("Error in meta_write_to_file: \{error}", error~)
  }
}

///|
pub fn new(agent : @agent.Agent) -> @tool.Tool[MetaWriteToFileResult] {
  @tool.new(
    description="Enhanced file writing tool that writes content to a file, automatically formats MoonBit files using moon fmt, checks for syntax errors with moon check, and spawns a sub-agent to fix any syntax errors found. This ensures that MoonBit files are always properly formatted and syntactically correct after writing. Returns diff comparison if final content differs from initial write.",
    name="meta_write_to_file",
    schema=meta_schema,
    async fn(args) -> @tool.ToolResult[MetaWriteToFileResult] noraise {
      execute_meta_write_to_file(args, agent)
    },
  )
}
